module Generator exposing (requestToResponse)

import Dict
import Elm.CodeGen as C
import Elm.Pretty
import Elm.Syntax.Module as Module
import Elm.Syntax.Node as Node
import Errors exposing (Res)
import Generator.Declarations exposing (removeDuplicateDeclarations)
import Generator.Enum as Enum
import Generator.Import as Import
import Generator.Message as Message
import Generator.OneOf as OneOf
import Generator.Service as Service
import Mapper as Mapper exposing (TypeRefs)
import Mapper.Name as Name
import Mapper.Package as Package exposing (Packages)
import Mapper.Struct exposing (Struct)
import Model exposing (Field(..))
import Proto.Google.Protobuf.Compiler.Plugin exposing (CodeGeneratorRequest, CodeGeneratorResponse, CodeGeneratorResponse_File)
import Proto.Google.Protobuf.Descriptor exposing (FileDescriptorProto)
import Protobuf.Types.Int64
import Result.Extra
import Set


type alias Versions =
    { plugin : String
    , library : String
    , compiler : String
    }


type alias Flags =
    { grpcOn : Bool
    }


requestToResponse :
    Versions
    -> Flags
    -> CodeGeneratorRequest
    -> CodeGeneratorResponse
requestToResponse versions flags req =
    let
        filesToResponse : Res (List CodeGeneratorResponse_File) -> CodeGeneratorResponse
        filesToResponse fileResults =
            case fileResults of
                Err error ->
                    { error = Errors.format error, supportedFeatures = Protobuf.Types.Int64.fromInts 0 3, file = [] }

                Ok file ->
                    { error = "", supportedFeatures = Protobuf.Types.Int64.fromInts 0 3, file = file }

        files =
            convert versions flags req.fileToGenerate req.protoFile
    in
    files |> Result.map (List.map generate) |> filesToResponse


generate : C.File -> CodeGeneratorResponse_File
generate file =
    { name = (Node.value file.moduleDefinition |> Module.moduleName |> String.join "/") ++ ".elm"
    , content = "{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}\n\n" ++ Elm.Pretty.pretty 120 file
    , insertionPoint = ""
    , generatedCodeInfo = Nothing
    }


convert : Versions -> Flags -> List String -> List FileDescriptorProto -> Res (List C.File)
convert versions flags fileNames descriptors =
    let
        files : Res Packages
        files =
            descriptors
                |> List.filter (.name >> (\name -> List.member name fileNames))
                |> Mapper.mapMain flags.grpcOn
                -- TODO we do not need the first el of the tuple anymore
                |> Errors.combineMap Tuple.second
                |> Result.map Package.concat

        --|> Result.map (\packages -> Package.addPackage [ "Proto", "Internals_" ] (Package.unify packages) packages)
        mkInternalsFile : Packages -> C.File
        mkInternalsFile =
            packageToFile [ "Proto", "Internals_" ] << Package.unify

        packageToFile : List String -> Struct -> C.File
        packageToFile packageName struct =
            let
                declarations =
                    List.concatMap Enum.toAST struct.enums
                        ++ List.concatMap Message.toAST struct.messages
                        ++ List.concatMap (Service.toAST packageName) struct.services
                        ++ List.concatMap OneOf.toAST struct.oneOfs
            in
            C.file
                (C.normalModule packageName [])
                (List.map (\importedModule -> C.importStmt importedModule Nothing Nothing) (Set.toList <| Import.extractImports declarations))
                (removeDuplicateDeclarations declarations)
                --TODO restore filename here somehow
                (C.emptyFileComment |> fileComment versions "filename" |> Just)

        packageToReexportFile : List String -> Struct -> C.File
        packageToReexportFile packageName struct =
            let
                declarations =
                    List.concatMap (Enum.reexportAST packageName) struct.enums
                        ++ List.concatMap (Message.reexportAST packageName) struct.messages
                        ++ List.concatMap (OneOf.reexportAST packageName) struct.oneOfs

                --++ List.concatMap (Service.toAST packageName) struct.services
            in
            C.file
                (C.normalModule packageName [])
                (List.map (\importedModule -> C.importStmt importedModule Nothing Nothing) (Set.toList <| Import.extractImports declarations))
                (removeDuplicateDeclarations declarations)
                --TODO restore filename here somehow
                (C.emptyFileComment |> fileComment versions "filename" |> Just)
    in
    Result.map
        (\packages -> Dict.map packageToReexportFile packages |> Dict.values |> (::) (mkInternalsFile packages))
        files


fileComment : Versions -> String -> C.Comment C.FileComment -> C.Comment C.FileComment
fileComment versions fileName =
    C.markdown <| """
This file was automatically generated by
- [`protoc-gen-elm`](https://www.npmjs.com/package/protoc-gen-elm) """ ++ versions.plugin ++ """
- `protoc` """ ++ versions.compiler ++ """
- the following specification file: `""" ++ fileName ++ """`

To run it, add a dependency via `elm install` on [`elm-protocol-buffers`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.2.0) version """ ++ versions.library ++ """ or higher."""
