{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}

module Proto.Google.Protobuf exposing (DescriptorProto, DescriptorProto_, EnumDescriptorProto, EnumOptions, EnumValueDescriptorProto, EnumValueOptions, ExtensionRangeOptions, FieldDescriptorProto, FieldOptions, FileDescriptorProto, FileDescriptorSet, FileOptions, GeneratedCodeInfo, MessageOptions, MethodDescriptorProto, MethodOptions, OneofDescriptorProto, OneofOptions, ServiceDescriptorProto, ServiceOptions, SourceCodeInfo, Timestamp, UninterpretedOption, decodeDescriptorProto, decodeEnumDescriptorProto, decodeEnumOptions, decodeEnumValueDescriptorProto, decodeEnumValueOptions, decodeExtensionRangeOptions, decodeFieldDescriptorProto, decodeFieldOptions, decodeFileDescriptorProto, decodeFileDescriptorSet, decodeFileOptions, decodeGeneratedCodeInfo, decodeMessageOptions, decodeMethodDescriptorProto, decodeMethodOptions, decodeOneofDescriptorProto, decodeOneofOptions, decodeServiceDescriptorProto, decodeServiceOptions, decodeSourceCodeInfo, decodeTimestamp, decodeUninterpretedOption, defaultDescriptorProto, defaultEnumDescriptorProto, defaultEnumOptions, defaultEnumValueDescriptorProto, defaultEnumValueOptions, defaultExtensionRangeOptions, defaultFieldDescriptorProto, defaultFieldOptions, defaultFileDescriptorProto, defaultFileDescriptorSet, defaultFileOptions, defaultGeneratedCodeInfo, defaultMessageOptions, defaultMethodDescriptorProto, defaultMethodOptions, defaultOneofDescriptorProto, defaultOneofOptions, defaultServiceDescriptorProto, defaultServiceOptions, defaultSourceCodeInfo, defaultTimestamp, defaultUninterpretedOption, encodeDescriptorProto, encodeEnumDescriptorProto, encodeEnumOptions, encodeEnumValueDescriptorProto, encodeEnumValueOptions, encodeExtensionRangeOptions, encodeFieldDescriptorProto, encodeFieldOptions, encodeFileDescriptorProto, encodeFileDescriptorSet, encodeFileOptions, encodeGeneratedCodeInfo, encodeMessageOptions, encodeMethodDescriptorProto, encodeMethodOptions, encodeOneofDescriptorProto, encodeOneofOptions, encodeServiceDescriptorProto, encodeServiceOptions, encodeSourceCodeInfo, encodeTimestamp, encodeUninterpretedOption, fieldNumbersDescriptorProto, fieldNumbersEnumDescriptorProto, fieldNumbersEnumOptions, fieldNumbersEnumValueDescriptorProto, fieldNumbersEnumValueOptions, fieldNumbersExtensionRangeOptions, fieldNumbersFieldDescriptorProto, fieldNumbersFieldOptions, fieldNumbersFileDescriptorProto, fieldNumbersFileDescriptorSet, fieldNumbersFileOptions, fieldNumbersGeneratedCodeInfo, fieldNumbersMessageOptions, fieldNumbersMethodDescriptorProto, fieldNumbersMethodOptions, fieldNumbersOneofDescriptorProto, fieldNumbersOneofOptions, fieldNumbersServiceDescriptorProto, fieldNumbersServiceOptions, fieldNumbersSourceCodeInfo, fieldNumbersTimestamp, fieldNumbersUninterpretedOption, unwrapDescriptorProto, wrapDescriptorProto)

{-| 
This file was automatically generated by
- [`protoc-gen-elm`](https://www.npmjs.com/package/protoc-gen-elm) 3.1.0-beta.1
- `protoc` 3.19.4
- the following specification files: `google/protobuf/descriptor.proto, google/protobuf/timestamp.proto`

To run it, add a dependency via `elm install` on [`elm-protocol-buffers`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.2.0) version 1.2.0 or higher.


 Protocol Buffers - Google's data interchange format
 Copyright 2008 Google Inc.  All rights reserved.
 https://developers.google.com/protocol-buffers/

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

     * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following disclaimer
 in the documentation and/or other materials provided with the
 distribution.
     * Neither the name of Google Inc. nor the names of its
 contributors may be used to endorse or promote products derived from
 this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



 Author: kenton@google.com (Kenton Varda)
  Based on original Protocol Buffers design by
  Sanjay Ghemawat, Jeff Dean, and others.

 The messages in this file describe the definitions found in .proto files.
 A valid .proto file can be translated directly to a FileDescriptorProto
 without any other information (e.g. without reading its imports).



@docs DescriptorProto, DescriptorProto_, EnumDescriptorProto, EnumOptions, EnumValueDescriptorProto, EnumValueOptions
@docs ExtensionRangeOptions, FieldDescriptorProto, FieldOptions, FileDescriptorProto, FileDescriptorSet, FileOptions, GeneratedCodeInfo
@docs MessageOptions, MethodDescriptorProto, MethodOptions, OneofDescriptorProto, OneofOptions, ServiceDescriptorProto, ServiceOptions
@docs SourceCodeInfo, Timestamp, UninterpretedOption, decodeDescriptorProto, decodeEnumDescriptorProto, decodeEnumOptions
@docs decodeEnumValueDescriptorProto, decodeEnumValueOptions, decodeExtensionRangeOptions, decodeFieldDescriptorProto
@docs decodeFieldOptions, decodeFileDescriptorProto, decodeFileDescriptorSet, decodeFileOptions, decodeGeneratedCodeInfo
@docs decodeMessageOptions, decodeMethodDescriptorProto, decodeMethodOptions, decodeOneofDescriptorProto, decodeOneofOptions
@docs decodeServiceDescriptorProto, decodeServiceOptions, decodeSourceCodeInfo, decodeTimestamp, decodeUninterpretedOption
@docs defaultDescriptorProto, defaultEnumDescriptorProto, defaultEnumOptions, defaultEnumValueDescriptorProto, defaultEnumValueOptions
@docs defaultExtensionRangeOptions, defaultFieldDescriptorProto, defaultFieldOptions, defaultFileDescriptorProto
@docs defaultFileDescriptorSet, defaultFileOptions, defaultGeneratedCodeInfo, defaultMessageOptions, defaultMethodDescriptorProto
@docs defaultMethodOptions, defaultOneofDescriptorProto, defaultOneofOptions, defaultServiceDescriptorProto, defaultServiceOptions
@docs defaultSourceCodeInfo, defaultTimestamp, defaultUninterpretedOption, encodeDescriptorProto, encodeEnumDescriptorProto
@docs encodeEnumOptions, encodeEnumValueDescriptorProto, encodeEnumValueOptions, encodeExtensionRangeOptions
@docs encodeFieldDescriptorProto, encodeFieldOptions, encodeFileDescriptorProto, encodeFileDescriptorSet, encodeFileOptions
@docs encodeGeneratedCodeInfo, encodeMessageOptions, encodeMethodDescriptorProto, encodeMethodOptions, encodeOneofDescriptorProto
@docs encodeOneofOptions, encodeServiceDescriptorProto, encodeServiceOptions, encodeSourceCodeInfo, encodeTimestamp
@docs encodeUninterpretedOption, fieldNumbersDescriptorProto, fieldNumbersEnumDescriptorProto, fieldNumbersEnumOptions
@docs fieldNumbersEnumValueDescriptorProto, fieldNumbersEnumValueOptions, fieldNumbersExtensionRangeOptions
@docs fieldNumbersFieldDescriptorProto, fieldNumbersFieldOptions, fieldNumbersFileDescriptorProto, fieldNumbersFileDescriptorSet
@docs fieldNumbersFileOptions, fieldNumbersGeneratedCodeInfo, fieldNumbersMessageOptions, fieldNumbersMethodDescriptorProto
@docs fieldNumbersMethodOptions, fieldNumbersOneofDescriptorProto, fieldNumbersOneofOptions, fieldNumbersServiceDescriptorProto
@docs fieldNumbersServiceOptions, fieldNumbersSourceCodeInfo, fieldNumbersTimestamp, fieldNumbersUninterpretedOption
@docs unwrapDescriptorProto, wrapDescriptorProto
-}

import Proto.Google.Protobuf.Internals_
import Protobuf.Decode
import Protobuf.Encode


{-| The field numbers for the fields of `Timestamp`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersTimestamp : { seconds : Int, nanos : Int }
fieldNumbersTimestamp =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Timestamp


{-| Default for Timestamp. Should only be used for 'required' decoders as an initial value.


-}
defaultTimestamp : Timestamp
defaultTimestamp =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Timestamp


{-| Declares how to decode a `Timestamp` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeTimestamp : Protobuf.Decode.Decoder Timestamp
decodeTimestamp =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Timestamp


{-| Declares how to encode a `Timestamp` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeTimestamp : Timestamp -> Protobuf.Encode.Encoder
encodeTimestamp =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Timestamp


{-|  A Timestamp represents a point in time independent of any time zone or local
 calendar, encoded as a count of seconds and fractions of seconds at
 nanosecond resolution. The count is relative to an epoch at UTC midnight on
 January 1, 1970, in the proleptic Gregorian calendar which extends the
 Gregorian calendar backwards to year one.

 All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
 second table is needed for interpretation, using a [24-hour linear
 smear](https://developers.google.com/time/smear).

 The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 restricting to that range, we ensure that we can convert to and from [RFC
 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.

 # Examples

 Example 1: Compute Timestamp from POSIX `time()`.

     Timestamp timestamp;
     timestamp.set_seconds(time(NULL));
     timestamp.set_nanos(0);

 Example 2: Compute Timestamp from POSIX `gettimeofday()`.

     struct timeval tv;
     gettimeofday(&tv, NULL);

     Timestamp timestamp;
     timestamp.set_seconds(tv.tv_sec);
     timestamp.set_nanos(tv.tv_usec * 1000);

 Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.

     FILETIME ft;
     GetSystemTimeAsFileTime(&ft);
     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;

     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
     Timestamp timestamp;
     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));

 Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

     long millis = System.currentTimeMillis();

     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
         .setNanos((int) ((millis % 1000) * 1000000)).build();


 Example 5: Compute Timestamp from Java `Instant.now()`.

     Instant now = Instant.now();

     Timestamp timestamp =
         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
             .setNanos(now.getNano()).build();


 Example 6: Compute Timestamp from current time in Python.

     timestamp = Timestamp()
     timestamp.GetCurrentTime()

 # JSON Mapping

 In JSON format, the Timestamp type is encoded as a string in the
 [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
 where {year} is always expressed using four digits while {month}, {day},
 {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
 is required. A proto3 JSON serializer should always use UTC (as indicated by
 "Z") when printing the Timestamp type and a proto3 JSON parser should be
 able to accept both UTC and other timezones (as indicated by an offset).

 For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
 01:30 UTC on January 15, 2017.

 In JavaScript, one can convert a Date object to this format using the
 standard
 [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 method. In Python, a standard `datetime.datetime` object can be converted
 to this format using
 [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
 the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 the Joda Time's [`ISODateTimeFormat.dateTime()`](
 http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
 ) to obtain a formatter capable of generating timestamps in this format.





## Fields


### seconds


 Represents seconds of UTC time since Unix epoch
 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
 9999-12-31T23:59:59Z inclusive.



### nanos


 Non-negative fractions of a second at nanosecond resolution. Negative
 second values with fractions must still have non-negative nanos values
 that count forward in time. Must be from 0 to 999,999,999
 inclusive.



-}
type alias Timestamp =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Timestamp


{-| The field numbers for the fields of `GeneratedCodeInfo`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersGeneratedCodeInfo : { annotation : Int }
fieldNumbersGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__GeneratedCodeInfo


{-| Default for GeneratedCodeInfo. Should only be used for 'required' decoders as an initial value.


-}
defaultGeneratedCodeInfo : GeneratedCodeInfo
defaultGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__GeneratedCodeInfo


{-| Declares how to decode a `GeneratedCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeGeneratedCodeInfo : Protobuf.Decode.Decoder GeneratedCodeInfo
decodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__GeneratedCodeInfo


{-| Declares how to encode a `GeneratedCodeInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeGeneratedCodeInfo : GeneratedCodeInfo -> Protobuf.Encode.Encoder
encodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__GeneratedCodeInfo


{-|  Describes the relationship between generated code and its original source
 file. A GeneratedCodeInfo message is associated with only one generated
 source file, but may contain references to different source .proto files.



## Fields


### annotation


 An Annotation connects some span of text in generated code to an element
 of its generating .proto file.



-}
type alias GeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__GeneratedCodeInfo


{-| The field numbers for the fields of `SourceCodeInfo`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersSourceCodeInfo : { location : Int }
fieldNumbersSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__SourceCodeInfo


{-| Default for SourceCodeInfo. Should only be used for 'required' decoders as an initial value.


-}
defaultSourceCodeInfo : SourceCodeInfo
defaultSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__SourceCodeInfo


{-| Declares how to decode a `SourceCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeSourceCodeInfo : Protobuf.Decode.Decoder SourceCodeInfo
decodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__SourceCodeInfo


{-| Declares how to encode a `SourceCodeInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeSourceCodeInfo : SourceCodeInfo -> Protobuf.Encode.Encoder
encodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__SourceCodeInfo


{-|  ===================================================================
 Optional source code info



 Encapsulates information about the original source file from which a
 FileDescriptorProto was generated.



## Fields


### location


 A Location identifies a piece of source code in a .proto file which
 corresponds to a particular definition.  This information is intended
 to be useful to IDEs, code indexers, documentation generators, and similar
 tools.

 For example, say we have a file like:
   message Foo {
     optional string foo = 1;
   }
 Let's look at just the field definition:
   optional string foo = 1;
   ^       ^^     ^^  ^  ^^^
   a       bc     de  f  ghi
 We have the following locations:
   span   path               represents
   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).

 Notes:
 - A location may refer to a repeated field itself (i.e. not to any
   particular index within it).  This is used whenever a set of elements are
   logically enclosed in a single code segment.  For example, an entire
   extend block (possibly containing multiple extension definitions) will
   have an outer location whose path refers to the "extensions" repeated
   field without an index.
 - Multiple locations may have the same path.  This happens when a single
   logical declaration is spread out across multiple places.  The most
   obvious example is the "extend" block again -- there may be multiple
   extend blocks in the same scope, each of which will have the same path.
 - A location's span is not always a subset of its parent's span.  For
   example, the "extendee" of an extension declaration appears at the
   beginning of the "extend" block and is shared by all extensions within
   the block.
 - Just because a location's span is a subset of some other location's span
   does not mean that it is a descendant.  For example, a "group" defines
   both a type and a field in a single declaration.  Thus, the locations
   corresponding to the type and field and their components will overlap.
 - Code which tries to interpret locations should probably be designed to
   ignore those that it doesn't understand, as more types of locations could
   be recorded in the future.



-}
type alias SourceCodeInfo =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__SourceCodeInfo


{-| The field numbers for the fields of `UninterpretedOption`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersUninterpretedOption :
    { name : Int
    , identifierValue : Int
    , positiveIntValue : Int
    , negativeIntValue : Int
    , doubleValue : Int
    , stringValue : Int
    , aggregateValue : Int
    }
fieldNumbersUninterpretedOption =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__UninterpretedOption


{-| Default for UninterpretedOption. Should only be used for 'required' decoders as an initial value.


-}
defaultUninterpretedOption : UninterpretedOption
defaultUninterpretedOption =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__UninterpretedOption


{-| Declares how to decode a `UninterpretedOption` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeUninterpretedOption : Protobuf.Decode.Decoder UninterpretedOption
decodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__UninterpretedOption


{-| Declares how to encode a `UninterpretedOption` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeUninterpretedOption : UninterpretedOption -> Protobuf.Encode.Encoder
encodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__UninterpretedOption


{-|  A message representing a option the parser does not recognize. This only
 appears in options protos created by the compiler::Parser class.
 DescriptorPool resolves these when building Descriptor objects. Therefore,
 options protos in descriptor objects (e.g. returned by Descriptor::options(),
 or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 in them.



## Fields


### identifier_value


 The value of the uninterpreted option, in whatever type the tokenizer
 identified it as during parsing. Exactly one of these should be set.



-}
type alias UninterpretedOption =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__UninterpretedOption


{-| The field numbers for the fields of `MethodOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersMethodOptions : { deprecated : Int, idempotencyLevel : Int, uninterpretedOption : Int }
fieldNumbersMethodOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MethodOptions


{-| Default for MethodOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultMethodOptions : MethodOptions
defaultMethodOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MethodOptions


{-| Declares how to decode a `MethodOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeMethodOptions : Protobuf.Decode.Decoder MethodOptions
decodeMethodOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MethodOptions


{-| Declares how to encode a `MethodOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeMethodOptions : MethodOptions -> Protobuf.Encode.Encoder
encodeMethodOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MethodOptions


{-| ## Fields


### deprecated


 Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
   framework.  We apologize for hoarding these numbers to ourselves, but
   we were already using them long before we decided to release Protocol
   Buffers.



 Is this method deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the method, or it will be completely ignored; in the very least,
 this is a formalization for deprecating methods.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias MethodOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MethodOptions


{-| The field numbers for the fields of `ServiceOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersServiceOptions : { deprecated : Int, uninterpretedOption : Int }
fieldNumbersServiceOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ServiceOptions


{-| Default for ServiceOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultServiceOptions : ServiceOptions
defaultServiceOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ServiceOptions


{-| Declares how to decode a `ServiceOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeServiceOptions : Protobuf.Decode.Decoder ServiceOptions
decodeServiceOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ServiceOptions


{-| Declares how to encode a `ServiceOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeServiceOptions : ServiceOptions -> Protobuf.Encode.Encoder
encodeServiceOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ServiceOptions


{-| ## Fields


### deprecated


 Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
   framework.  We apologize for hoarding these numbers to ourselves, but
   we were already using them long before we decided to release Protocol
   Buffers.



 Is this service deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the service, or it will be completely ignored; in the very least,
 this is a formalization for deprecating services.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias ServiceOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ServiceOptions


{-| The field numbers for the fields of `EnumValueOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersEnumValueOptions : { deprecated : Int, uninterpretedOption : Int }
fieldNumbersEnumValueOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumValueOptions


{-| Default for EnumValueOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultEnumValueOptions : EnumValueOptions
defaultEnumValueOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumValueOptions


{-| Declares how to decode a `EnumValueOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeEnumValueOptions : Protobuf.Decode.Decoder EnumValueOptions
decodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumValueOptions


{-| Declares how to encode a `EnumValueOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeEnumValueOptions : EnumValueOptions -> Protobuf.Encode.Encoder
encodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumValueOptions


{-| ## Fields


### deprecated


 Is this enum value deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the enum value, or it will be completely ignored; in the very least,
 this is a formalization for deprecating enum values.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias EnumValueOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumValueOptions


{-| The field numbers for the fields of `EnumOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersEnumOptions : { allowAlias : Int, deprecated : Int, uninterpretedOption : Int }
fieldNumbersEnumOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumOptions


{-| Default for EnumOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultEnumOptions : EnumOptions
defaultEnumOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumOptions


{-| Declares how to decode a `EnumOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeEnumOptions : Protobuf.Decode.Decoder EnumOptions
decodeEnumOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumOptions


{-| Declares how to encode a `EnumOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeEnumOptions : EnumOptions -> Protobuf.Encode.Encoder
encodeEnumOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumOptions


{-| ## Fields


### allow_alias


 Set this option to true to allow mapping different tag names to the same
 value.



### deprecated


 Is this enum deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the enum, or it will be completely ignored; in the very least, this
 is a formalization for deprecating enums.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias EnumOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumOptions


{-| The field numbers for the fields of `OneofOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersOneofOptions : { uninterpretedOption : Int }
fieldNumbersOneofOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__OneofOptions


{-| Default for OneofOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultOneofOptions : OneofOptions
defaultOneofOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__OneofOptions


{-| Declares how to decode a `OneofOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeOneofOptions : Protobuf.Decode.Decoder OneofOptions
decodeOneofOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__OneofOptions


{-| Declares how to encode a `OneofOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeOneofOptions : OneofOptions -> Protobuf.Encode.Encoder
encodeOneofOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__OneofOptions


{-| ## Fields


### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias OneofOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__OneofOptions


{-| The field numbers for the fields of `FieldOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersFieldOptions :
    { ctype : Int, packed : Int, jstype : Int, lazy : Int, deprecated : Int, weak : Int, uninterpretedOption : Int }
fieldNumbersFieldOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FieldOptions


{-| Default for FieldOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultFieldOptions : FieldOptions
defaultFieldOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FieldOptions


{-| Declares how to decode a `FieldOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeFieldOptions : Protobuf.Decode.Decoder FieldOptions
decodeFieldOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FieldOptions


{-| Declares how to encode a `FieldOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeFieldOptions : FieldOptions -> Protobuf.Encode.Encoder
encodeFieldOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FieldOptions


{-| ## Fields


### ctype


 The ctype option instructs the C++ code generator to use a different
 representation of the field than it normally would.  See the specific
 options below.  This option is not yet implemented in the open source
 release -- sorry, we'll try to include it in a future version!



### packed


 The packed option can be enabled for repeated primitive fields to enable
 a more efficient representation on the wire. Rather than repeatedly
 writing the tag and type for each element, the entire array is encoded as
 a single length-delimited blob. In proto3, only explicit setting it to
 false will avoid using packed encoding.



### jstype


 The jstype option determines the JavaScript type used for values of the
 field.  The option is permitted only for 64 bit integral and fixed types
 (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
 is represented as JavaScript string, which avoids loss of precision that
 can happen when a large value is converted to a floating point JavaScript.
 Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
 use the JavaScript "number" type.  The behavior of the default option
 JS_NORMAL is implementation dependent.

 This option is an enum to permit additional types to be added, e.g.
 goog.math.Integer.



### lazy


 Should this field be parsed lazily?  Lazy applies only to message-type
 fields.  It means that when the outer message is initially parsed, the
 inner message's contents will not be parsed but instead stored in encoded
 form.  The inner message will actually be parsed when it is first accessed.

 This is only a hint.  Implementations are free to choose whether to use
 eager or lazy parsing regardless of the value of this option.  However,
 setting this option true suggests that the protocol author believes that
 using lazy parsing on this field is worth the additional bookkeeping
 overhead typically needed to implement it.

 This option does not affect the public interface of any generated code;
 all method signatures remain the same.  Furthermore, thread-safety of the
 interface is not affected by this option; const methods remain safe to
 call from multiple threads concurrently, while non-const methods continue
 to require exclusive access.


 Note that implementations may choose not to check required fields within
 a lazy sub-message.  That is, calling IsInitialized() on the outer message
 may return true even if the inner message has missing required fields.
 This is necessary because otherwise the inner message would have to be
 parsed in order to perform the check, defeating the purpose of lazy
 parsing.  An implementation which chooses not to check required fields
 must be consistent about it.  That is, for any particular sub-message, the
 implementation must either *always* check its required fields, or *never*
 check its required fields, regardless of whether or not the message has
 been parsed.



### deprecated


 Is this field deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for accessors, or it will be completely ignored; in the very least, this
 is a formalization for deprecating fields.



### weak


 For Google-internal migration only. Do not use.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias FieldOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FieldOptions


{-| The field numbers for the fields of `MessageOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersMessageOptions :
    { messageSetWireFormat : Int
    , noStandardDescriptorAccessor : Int
    , deprecated : Int
    , mapEntry : Int
    , uninterpretedOption : Int
    }
fieldNumbersMessageOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MessageOptions


{-| Default for MessageOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultMessageOptions : MessageOptions
defaultMessageOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MessageOptions


{-| Declares how to decode a `MessageOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeMessageOptions : Protobuf.Decode.Decoder MessageOptions
decodeMessageOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MessageOptions


{-| Declares how to encode a `MessageOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeMessageOptions : MessageOptions -> Protobuf.Encode.Encoder
encodeMessageOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MessageOptions


{-| ## Fields


### message_set_wire_format


 Set true to use the old proto1 MessageSet wire format for extensions.
 This is provided for backwards-compatibility with the MessageSet wire
 format.  You should not use this for any other reason:  It's less
 efficient, has fewer features, and is more complicated.

 The message must be defined exactly as follows:
   message Foo {
     option message_set_wire_format = true;
     extensions 4 to max;
   }
 Note that the message cannot have any defined fields; MessageSets only
 have extensions.

 All extensions of your type must be singular messages; e.g. they cannot
 be int32s, enums, or repeated messages.

 Because this is an option, the above two restrictions are not enforced by
 the protocol compiler.



### no_standard_descriptor_accessor


 Disables the generation of the standard "descriptor()" accessor, which can
 conflict with a field of the same name.  This is meant to make migration
 from proto1 easier; new code should avoid fields named "descriptor".



### deprecated


 Is this message deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the message, or it will be completely ignored; in the very least,
 this is a formalization for deprecating messages.



### map_entry


 Whether the message is an automatically generated map entry type for the
 maps field.

 For maps fields:
     map<KeyType, ValueType> map_field = 1;
 The parsed descriptor looks like:
     message MapFieldEntry {
         option map_entry = true;
         optional KeyType key = 1;
         optional ValueType value = 2;
     }
     repeated MapFieldEntry map_field = 1;

 Implementations may choose not to generate the map_entry=true message, but
 use a native map in the target language to hold the keys and values.
 The reflection APIs in such implementations still need to work as
 if the field is a repeated message field.

 NOTE: Do not set the option in .proto files. Always use the maps syntax
 instead. The option should only be implicitly set by the proto compiler
 parser.



### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias MessageOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MessageOptions


{-| The field numbers for the fields of `FileOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersFileOptions :
    { javaPackage : Int
    , javaOuterClassname : Int
    , javaMultipleFiles : Int
    , javaGenerateEqualsAndHash : Int
    , javaStringCheckUtf8 : Int
    , optimizeFor : Int
    , goPackage : Int
    , ccGenericServices : Int
    , javaGenericServices : Int
    , pyGenericServices : Int
    , phpGenericServices : Int
    , deprecated : Int
    , ccEnableArenas : Int
    , objcClassPrefix : Int
    , csharpNamespace : Int
    , swiftPrefix : Int
    , phpClassPrefix : Int
    , phpNamespace : Int
    , phpMetadataNamespace : Int
    , rubyPackage : Int
    , uninterpretedOption : Int
    }
fieldNumbersFileOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileOptions


{-| Default for FileOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultFileOptions : FileOptions
defaultFileOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileOptions


{-| Declares how to decode a `FileOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeFileOptions : Protobuf.Decode.Decoder FileOptions
decodeFileOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileOptions


{-| Declares how to encode a `FileOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeFileOptions : FileOptions -> Protobuf.Encode.Encoder
encodeFileOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileOptions


{-|  ===================================================================
 Options



 Each of the definitions above may have "options" attached.  These are
 just annotations which may cause code to be generated slightly differently
 or may contain hints for code that manipulates protocol messages.

 Clients may define custom options as extensions of the *Options messages.
 These extensions may not yet be known at parsing time, so the parser cannot
 store the values in them.  Instead it stores them in a field in the *Options
 message called uninterpreted_option. This field must have the same name
 across all *Options messages. We then use this field to populate the
 extensions when we build a descriptor, at which point all protos have been
 parsed and so all extensions are known.

 Extension numbers for custom options may be chosen as follows:
 * For options which will only be used within a single application or
   organization, or for experimental options, use field numbers 50000
   through 99999.  It is up to you to ensure that you do not use the
   same number for multiple options.
 * For options which will be published and used publicly by multiple
   independent entities, e-mail protobuf-global-extension-registry@google.com
   to reserve extension numbers. Simply provide your project name (e.g.
   Objective-C plugin) and your project website (if available) -- there's no
   need to explain how you intend to use them. Usually you only need one
   extension number. You can declare multiple options with only one extension
   number by putting them in a sub-message. See the Custom Options section of
   the docs for examples:
   https://developers.google.com/protocol-buffers/docs/proto#options
   If this turns out to be popular, a web service will be set up
   to automatically assign option numbers.



## Fields


### java_package


 Sets the Java package where classes generated from this .proto will be
 placed.  By default, the proto package is used, but this is often
 inappropriate because proto packages do not normally start with backwards
 domain names.



### java_outer_classname


 Controls the name of the wrapper Java class generated for the .proto file.
 That class will always contain the .proto file's getDescriptor() method as
 well as any top-level extensions defined in the .proto file.
 If java_multiple_files is disabled, then all the other classes from the
 .proto file will be nested inside the single wrapper outer class.



### java_multiple_files


 If enabled, then the Java code generator will generate a separate .java
 file for each top-level message, enum, and service defined in the .proto
 file.  Thus, these types will *not* be nested inside the wrapper class
 named by java_outer_classname.  However, the wrapper class will still be
 generated to contain the file's getDescriptor() method as well as any
 top-level extensions defined in the file.



### java_generate_equals_and_hash


 This option does nothing.



### java_string_check_utf8


 If set true, then the Java2 code generator will generate code that
 throws an exception whenever an attempt is made to assign a non-UTF-8
 byte sequence to a string field.
 Message reflection will do the same.
 However, an extension field still accepts non-UTF-8 byte sequences.
 This option has no effect on when used with the lite runtime.



### go_package


 Sets the Go package where structs generated from this .proto will be
 placed. If omitted, the Go package will be derived from the following:
   - The basename of the package import path, if provided.
   - Otherwise, the package statement in the .proto file, if present.
   - Otherwise, the basename of the .proto file, without extension.



### cc_generic_services


 Should generic services be generated in each language?  "Generic" services
 are not specific to any particular RPC system.  They are generated by the
 main code generators in each language (without additional plugins).
 Generic services were the only kind of service generation supported by
 early versions of google.protobuf.

 Generic services are now considered deprecated in favor of using plugins
 that generate code specific to your particular RPC system.  Therefore,
 these default to false.  Old code which depends on generic services should
 explicitly set them to true.



### deprecated


 Is this file deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for everything in the file, or it will be completely ignored; in the very
 least, this is a formalization for deprecating files.



### cc_enable_arenas


 Enables the use of arenas for the proto messages in this file. This applies
 only to generated classes for C++.



### objc_class_prefix


 Sets the objective c class prefix which is prepended to all objective c
 generated classes from this .proto. There is no default.



### csharp_namespace


 Namespace for generated classes; defaults to the package.



### swift_prefix


 By default Swift generators will take the proto package and CamelCase it
 replacing '.' with underscore and use that to prefix the types/symbols
 defined. When this options is provided, they will use this value instead
 to prefix the types/symbols defined.



### php_class_prefix


 Sets the php class prefix which is prepended to all php generated classes
 from this .proto. Default is empty.



### php_namespace


 Use this option to change the namespace of php generated classes. Default
 is empty. When this option is empty, the package name will be used for
 determining the namespace.



### php_metadata_namespace


 Use this option to change the namespace of php generated metadata classes.
 Default is empty. When this option is empty, the proto file name will be
 used for determining the namespace.



### ruby_package


 Use this option to change the package of ruby generated classes. Default
 is empty. When this option is not set, the package name will be used for
 determining the ruby package.



### uninterpreted_option


 The parser stores options it doesn't recognize here.
 See the documentation for the "Options" section above.



-}
type alias FileOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileOptions


{-| The field numbers for the fields of `MethodDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersMethodDescriptorProto :
    { name : Int, inputType : Int, outputType : Int, options : Int, clientStreaming : Int, serverStreaming : Int }
fieldNumbersMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MethodDescriptorProto


{-| Default for MethodDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultMethodDescriptorProto : MethodDescriptorProto
defaultMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MethodDescriptorProto


{-| Declares how to decode a `MethodDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeMethodDescriptorProto : Protobuf.Decode.Decoder MethodDescriptorProto
decodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MethodDescriptorProto


{-| Declares how to encode a `MethodDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeMethodDescriptorProto : MethodDescriptorProto -> Protobuf.Encode.Encoder
encodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MethodDescriptorProto


{-|  Describes a method of a service.



## Fields


### input_type


 Input and output type names.  These are resolved in the same way as
 FieldDescriptorProto.type_name, but must refer to a message type.



### client_streaming


 Identifies if client streams multiple client messages



### server_streaming


 Identifies if server streams multiple server messages



-}
type alias MethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MethodDescriptorProto


{-| The field numbers for the fields of `ServiceDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersServiceDescriptorProto : { name : Int, method : Int, options : Int }
fieldNumbersServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ServiceDescriptorProto


{-| Default for ServiceDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultServiceDescriptorProto : ServiceDescriptorProto
defaultServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ServiceDescriptorProto


{-| Declares how to decode a `ServiceDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeServiceDescriptorProto : Protobuf.Decode.Decoder ServiceDescriptorProto
decodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ServiceDescriptorProto


{-| Declares how to encode a `ServiceDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeServiceDescriptorProto : ServiceDescriptorProto -> Protobuf.Encode.Encoder
encodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ServiceDescriptorProto


{-|  Describes a service.



-}
type alias ServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ServiceDescriptorProto


{-| The field numbers for the fields of `EnumValueDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersEnumValueDescriptorProto : { name : Int, number : Int, options : Int }
fieldNumbersEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumValueDescriptorProto


{-| Default for EnumValueDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultEnumValueDescriptorProto : EnumValueDescriptorProto
defaultEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumValueDescriptorProto


{-| Declares how to decode a `EnumValueDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeEnumValueDescriptorProto : Protobuf.Decode.Decoder EnumValueDescriptorProto
decodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumValueDescriptorProto


{-| Declares how to encode a `EnumValueDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeEnumValueDescriptorProto : EnumValueDescriptorProto -> Protobuf.Encode.Encoder
encodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumValueDescriptorProto


{-|  Describes a value within an enum.



-}
type alias EnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumValueDescriptorProto


{-| The field numbers for the fields of `EnumDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersEnumDescriptorProto : { name : Int, value : Int, options : Int, reservedRange : Int, reservedName : Int }
fieldNumbersEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumDescriptorProto


{-| Default for EnumDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultEnumDescriptorProto : EnumDescriptorProto
defaultEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumDescriptorProto


{-| Declares how to decode a `EnumDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeEnumDescriptorProto : Protobuf.Decode.Decoder EnumDescriptorProto
decodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumDescriptorProto


{-| Declares how to encode a `EnumDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeEnumDescriptorProto : EnumDescriptorProto -> Protobuf.Encode.Encoder
encodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumDescriptorProto


{-|  Describes an enum type.



## Fields


### reserved_range


 Range of reserved numeric values. Reserved numeric values may not be used
 by enum values in the same enum declaration. Reserved ranges may not
 overlap.



### reserved_name


 Reserved enum value names, which may not be reused. A given name may only
 be reserved once.



-}
type alias EnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumDescriptorProto


{-| The field numbers for the fields of `OneofDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersOneofDescriptorProto : { name : Int, options : Int }
fieldNumbersOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__OneofDescriptorProto


{-| Default for OneofDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultOneofDescriptorProto : OneofDescriptorProto
defaultOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__OneofDescriptorProto


{-| Declares how to decode a `OneofDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeOneofDescriptorProto : Protobuf.Decode.Decoder OneofDescriptorProto
decodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__OneofDescriptorProto


{-| Declares how to encode a `OneofDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeOneofDescriptorProto : OneofDescriptorProto -> Protobuf.Encode.Encoder
encodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__OneofDescriptorProto


{-|  Describes a oneof.



-}
type alias OneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__OneofDescriptorProto


{-| The field numbers for the fields of `FieldDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersFieldDescriptorProto :
    { name : Int
    , number : Int
    , label : Int
    , type_ : Int
    , typeName : Int
    , extendee : Int
    , defaultValue : Int
    , oneofIndex : Int
    , jsonName : Int
    , options : Int
    , proto3Optional : Int
    }
fieldNumbersFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FieldDescriptorProto


{-| Default for FieldDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultFieldDescriptorProto : FieldDescriptorProto
defaultFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FieldDescriptorProto


{-| Declares how to decode a `FieldDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeFieldDescriptorProto : Protobuf.Decode.Decoder FieldDescriptorProto
decodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FieldDescriptorProto


{-| Declares how to encode a `FieldDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeFieldDescriptorProto : FieldDescriptorProto -> Protobuf.Encode.Encoder
encodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FieldDescriptorProto


{-|  Describes a field within a message.



## Fields


### type


 If type_name is set, this need not be set.  If both this and type_name
 are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.



### type_name


 For message and enum types, this is the name of the type.  If the name
 starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
 rules are used to find the type (i.e. first the nested types within this
 message are searched, then within the parent, on up to the root
 namespace).



### extendee


 For extensions, this is the name of the type being extended.  It is
 resolved in the same manner as type_name.



### default_value


 For numeric types, contains the original text representation of the value.
 For booleans, "true" or "false".
 For strings, contains the default text contents (not escaped in any way).
 For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
 TODO(kenton):  Base-64 encode?



### oneof_index


 If set, gives the index of a oneof in the containing type's oneof_decl
 list.  This field is a member of that oneof.



### json_name


 JSON name of this field. The value is set by protocol compiler. If the
 user has set a "json_name" option on this field, that option's value
 will be used. Otherwise, it's deduced from the field's name by converting
 it to camelCase.



### proto3_optional


 If true, this is a proto3 "optional". When a proto3 field is optional, it
 tracks presence regardless of field type.

 When proto3_optional is true, this field must be belong to a oneof to
 signal to old proto3 clients that presence is tracked for this field. This
 oneof is known as a "synthetic" oneof, and this field must be its sole
 member (each proto3 optional field gets its own synthetic oneof). Synthetic
 oneofs exist in the descriptor only, and do not generate any API. Synthetic
 oneofs must be ordered after all "real" oneofs.

 For message fields, proto3_optional doesn't create any semantic change,
 since non-repeated message fields always track presence. However it still
 indicates the semantic detail of whether the user wrote "optional" or not.
 This can be useful for round-tripping the .proto file. For consistency we
 give message fields a synthetic oneof also, even though it is not required
 to track presence. This is especially important because the parser can't
 tell if a field is a message or an enum, so it must always create a
 synthetic oneof.

 Proto2 optional fields do not set this flag, because they already indicate
 optional with `LABEL_OPTIONAL`.



-}
type alias FieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FieldDescriptorProto


{-| The field numbers for the fields of `ExtensionRangeOptions`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersExtensionRangeOptions : { uninterpretedOption : Int }
fieldNumbersExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ExtensionRangeOptions


{-| Default for ExtensionRangeOptions. Should only be used for 'required' decoders as an initial value.


-}
defaultExtensionRangeOptions : ExtensionRangeOptions
defaultExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ExtensionRangeOptions


{-| Declares how to decode a `ExtensionRangeOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeExtensionRangeOptions : Protobuf.Decode.Decoder ExtensionRangeOptions
decodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ExtensionRangeOptions


{-| Declares how to encode a `ExtensionRangeOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeExtensionRangeOptions : ExtensionRangeOptions -> Protobuf.Encode.Encoder
encodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ExtensionRangeOptions


{-| ## Fields


### uninterpreted_option


 The parser stores options it doesn't recognize here. See above.



-}
type alias ExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ExtensionRangeOptions


{-| Unwrap a `DescriptorProto` from its wrapper `DescriptorProto_.`


-}
unwrapDescriptorProto : DescriptorProto_ -> DescriptorProto
unwrapDescriptorProto =
    Proto.Google.Protobuf.Internals_.unwrapProto__Google__Protobuf__DescriptorProto


{-| Wrap a `DescriptorProto` into its wrapper `DescriptorProto_.`


-}
wrapDescriptorProto : DescriptorProto -> DescriptorProto_
wrapDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto_


{-| Type wrapper for alias type `DescriptorProto` to avoid unlimited recursion.


For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.


-}
type alias DescriptorProto_ =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto_


{-| The field numbers for the fields of `DescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersDescriptorProto :
    { name : Int
    , field : Int
    , extension : Int
    , nestedType : Int
    , enumType : Int
    , extensionRange : Int
    , oneofDecl : Int
    , options : Int
    , reservedRange : Int
    , reservedName : Int
    }
fieldNumbersDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__DescriptorProto


{-| Default for DescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultDescriptorProto : DescriptorProto
defaultDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__DescriptorProto


{-| Declares how to decode a `DescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeDescriptorProto : Protobuf.Decode.Decoder DescriptorProto
decodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__DescriptorProto


{-| Declares how to encode a `DescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeDescriptorProto : DescriptorProto -> Protobuf.Encode.Encoder
encodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__DescriptorProto


{-|  Describes a message type.



## Fields


### reserved_name


 Reserved field names, which may not be used by fields in the same message.
 A given name may only be reserved once.



-}
type alias DescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto


{-| The field numbers for the fields of `FileDescriptorProto`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersFileDescriptorProto :
    { name : Int
    , package : Int
    , dependency : Int
    , publicDependency : Int
    , weakDependency : Int
    , messageType : Int
    , enumType : Int
    , service : Int
    , extension : Int
    , options : Int
    , sourceCodeInfo : Int
    , syntax : Int
    }
fieldNumbersFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileDescriptorProto


{-| Default for FileDescriptorProto. Should only be used for 'required' decoders as an initial value.


-}
defaultFileDescriptorProto : FileDescriptorProto
defaultFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileDescriptorProto


{-| Declares how to decode a `FileDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeFileDescriptorProto : Protobuf.Decode.Decoder FileDescriptorProto
decodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileDescriptorProto


{-| Declares how to encode a `FileDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeFileDescriptorProto : FileDescriptorProto -> Protobuf.Encode.Encoder
encodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileDescriptorProto


{-|  Describes a complete .proto file.



## Fields


### name


 file name, relative to root of source tree



### package


 e.g. "foo", "foo.bar", etc.



### dependency


 Names of files imported by this file.



### public_dependency


 Indexes of the public imported files in the dependency list above.



### weak_dependency


 Indexes of the weak imported files in the dependency list.
 For Google-internal migration only. Do not use.



### message_type


 All top-level definitions in this file.



### source_code_info


 This field contains optional information about the original source code.
 You may safely remove this entire field without harming runtime
 functionality of the descriptors -- the information is needed only by
 development tools.



### syntax


 The syntax of the proto file.
 The supported values are "proto2" and "proto3".



-}
type alias FileDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileDescriptorProto


{-| The field numbers for the fields of `FileDescriptorSet`. This is mostly useful for internals, like documentation generation.


-}
fieldNumbersFileDescriptorSet : { file : Int }
fieldNumbersFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileDescriptorSet


{-| Default for FileDescriptorSet. Should only be used for 'required' decoders as an initial value.


-}
defaultFileDescriptorSet : FileDescriptorSet
defaultFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileDescriptorSet


{-| Declares how to decode a `FileDescriptorSet` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.


-}
decodeFileDescriptorSet : Protobuf.Decode.Decoder FileDescriptorSet
decodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileDescriptorSet


{-| Declares how to encode a `FileDescriptorSet` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.


-}
encodeFileDescriptorSet : FileDescriptorSet -> Protobuf.Encode.Encoder
encodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileDescriptorSet


{-|  The protocol compiler can output a FileDescriptorSet containing the .proto
 files it parses.



-}
type alias FileDescriptorSet =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileDescriptorSet
