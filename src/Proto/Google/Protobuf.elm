{- !!! DO NOT EDIT THIS FILE MANUALLY !!! -}

module Proto.Google.Protobuf exposing (Any, Api, BoolValue, BytesValue, DescriptorProto, DescriptorProto_, DoubleValue, Duration, Empty, Enum, EnumDescriptorProto, EnumOptions, EnumValue, EnumValueDescriptorProto, EnumValueOptions, ExtensionRangeOptions, Field, FieldDescriptorProto, FieldMask, FieldOptions, FileDescriptorProto, FileDescriptorSet, FileOptions, FloatValue, GeneratedCodeInfo, Int32Value, Int64Value, ListValue, ListValue_, MessageOptions, Method, MethodDescriptorProto, MethodOptions, Mixin, OneofDescriptorProto, OneofOptions, Option, ServiceDescriptorProto, ServiceOptions, SourceCodeInfo, SourceContext, StringValue, Struct, Timestamp, Type, UInt32Value, UInt64Value, UninterpretedOption, Value, Value_, decodeAny, decodeApi, decodeBoolValue, decodeBytesValue, decodeDescriptorProto, decodeDoubleValue, decodeDuration, decodeEmpty, decodeEnum, decodeEnumDescriptorProto, decodeEnumOptions, decodeEnumValue, decodeEnumValueDescriptorProto, decodeEnumValueOptions, decodeExtensionRangeOptions, decodeField, decodeFieldDescriptorProto, decodeFieldMask, decodeFieldOptions, decodeFileDescriptorProto, decodeFileDescriptorSet, decodeFileOptions, decodeFloatValue, decodeGeneratedCodeInfo, decodeInt32Value, decodeInt64Value, decodeListValue, decodeMessageOptions, decodeMethod, decodeMethodDescriptorProto, decodeMethodOptions, decodeMixin, decodeOneofDescriptorProto, decodeOneofOptions, decodeOption, decodeServiceDescriptorProto, decodeServiceOptions, decodeSourceCodeInfo, decodeSourceContext, decodeStringValue, decodeStruct, decodeTimestamp, decodeType, decodeUInt32Value, decodeUInt64Value, decodeUninterpretedOption, decodeValue, defaultAny, defaultApi, defaultBoolValue, defaultBytesValue, defaultDescriptorProto, defaultDoubleValue, defaultDuration, defaultEmpty, defaultEnum, defaultEnumDescriptorProto, defaultEnumOptions, defaultEnumValue, defaultEnumValueDescriptorProto, defaultEnumValueOptions, defaultExtensionRangeOptions, defaultField, defaultFieldDescriptorProto, defaultFieldMask, defaultFieldOptions, defaultFileDescriptorProto, defaultFileDescriptorSet, defaultFileOptions, defaultFloatValue, defaultGeneratedCodeInfo, defaultInt32Value, defaultInt64Value, defaultListValue, defaultMessageOptions, defaultMethod, defaultMethodDescriptorProto, defaultMethodOptions, defaultMixin, defaultOneofDescriptorProto, defaultOneofOptions, defaultOption, defaultServiceDescriptorProto, defaultServiceOptions, defaultSourceCodeInfo, defaultSourceContext, defaultStringValue, defaultStruct, defaultTimestamp, defaultType, defaultUInt32Value, defaultUInt64Value, defaultUninterpretedOption, defaultValue, encodeAny, encodeApi, encodeBoolValue, encodeBytesValue, encodeDescriptorProto, encodeDoubleValue, encodeDuration, encodeEmpty, encodeEnum, encodeEnumDescriptorProto, encodeEnumOptions, encodeEnumValue, encodeEnumValueDescriptorProto, encodeEnumValueOptions, encodeExtensionRangeOptions, encodeField, encodeFieldDescriptorProto, encodeFieldMask, encodeFieldOptions, encodeFileDescriptorProto, encodeFileDescriptorSet, encodeFileOptions, encodeFloatValue, encodeGeneratedCodeInfo, encodeInt32Value, encodeInt64Value, encodeListValue, encodeMessageOptions, encodeMethod, encodeMethodDescriptorProto, encodeMethodOptions, encodeMixin, encodeOneofDescriptorProto, encodeOneofOptions, encodeOption, encodeServiceDescriptorProto, encodeServiceOptions, encodeSourceCodeInfo, encodeSourceContext, encodeStringValue, encodeStruct, encodeTimestamp, encodeType, encodeUInt32Value, encodeUInt64Value, encodeUninterpretedOption, encodeValue, fieldNumbersAny, fieldNumbersApi, fieldNumbersBoolValue, fieldNumbersBytesValue, fieldNumbersDescriptorProto, fieldNumbersDoubleValue, fieldNumbersDuration, fieldNumbersEmpty, fieldNumbersEnum, fieldNumbersEnumDescriptorProto, fieldNumbersEnumOptions, fieldNumbersEnumValue, fieldNumbersEnumValueDescriptorProto, fieldNumbersEnumValueOptions, fieldNumbersExtensionRangeOptions, fieldNumbersField, fieldNumbersFieldDescriptorProto, fieldNumbersFieldMask, fieldNumbersFieldOptions, fieldNumbersFileDescriptorProto, fieldNumbersFileDescriptorSet, fieldNumbersFileOptions, fieldNumbersFloatValue, fieldNumbersGeneratedCodeInfo, fieldNumbersInt32Value, fieldNumbersInt64Value, fieldNumbersListValue, fieldNumbersMessageOptions, fieldNumbersMethod, fieldNumbersMethodDescriptorProto, fieldNumbersMethodOptions, fieldNumbersMixin, fieldNumbersOneofDescriptorProto, fieldNumbersOneofOptions, fieldNumbersOption, fieldNumbersServiceDescriptorProto, fieldNumbersServiceOptions, fieldNumbersSourceCodeInfo, fieldNumbersSourceContext, fieldNumbersStringValue, fieldNumbersStruct, fieldNumbersTimestamp, fieldNumbersType, fieldNumbersUInt32Value, fieldNumbersUInt64Value, fieldNumbersUninterpretedOption, fieldNumbersValue, jsonDecodeAny, jsonDecodeApi, jsonDecodeBoolValue, jsonDecodeBytesValue, jsonDecodeDescriptorProto, jsonDecodeDoubleValue, jsonDecodeDuration, jsonDecodeEmpty, jsonDecodeEnum, jsonDecodeEnumDescriptorProto, jsonDecodeEnumOptions, jsonDecodeEnumValue, jsonDecodeEnumValueDescriptorProto, jsonDecodeEnumValueOptions, jsonDecodeExtensionRangeOptions, jsonDecodeField, jsonDecodeFieldDescriptorProto, jsonDecodeFieldMask, jsonDecodeFieldOptions, jsonDecodeFileDescriptorProto, jsonDecodeFileDescriptorSet, jsonDecodeFileOptions, jsonDecodeFloatValue, jsonDecodeGeneratedCodeInfo, jsonDecodeInt32Value, jsonDecodeInt64Value, jsonDecodeListValue, jsonDecodeMessageOptions, jsonDecodeMethod, jsonDecodeMethodDescriptorProto, jsonDecodeMethodOptions, jsonDecodeMixin, jsonDecodeOneofDescriptorProto, jsonDecodeOneofOptions, jsonDecodeOption, jsonDecodeServiceDescriptorProto, jsonDecodeServiceOptions, jsonDecodeSourceCodeInfo, jsonDecodeSourceContext, jsonDecodeStringValue, jsonDecodeStruct, jsonDecodeTimestamp, jsonDecodeType, jsonDecodeUInt32Value, jsonDecodeUInt64Value, jsonDecodeUninterpretedOption, jsonDecodeValue, jsonEncodeAny, jsonEncodeApi, jsonEncodeBoolValue, jsonEncodeBytesValue, jsonEncodeDescriptorProto, jsonEncodeDoubleValue, jsonEncodeDuration, jsonEncodeEmpty, jsonEncodeEnum, jsonEncodeEnumDescriptorProto, jsonEncodeEnumOptions, jsonEncodeEnumValue, jsonEncodeEnumValueDescriptorProto, jsonEncodeEnumValueOptions, jsonEncodeExtensionRangeOptions, jsonEncodeField, jsonEncodeFieldDescriptorProto, jsonEncodeFieldMask, jsonEncodeFieldOptions, jsonEncodeFileDescriptorProto, jsonEncodeFileDescriptorSet, jsonEncodeFileOptions, jsonEncodeFloatValue, jsonEncodeGeneratedCodeInfo, jsonEncodeInt32Value, jsonEncodeInt64Value, jsonEncodeListValue, jsonEncodeMessageOptions, jsonEncodeMethod, jsonEncodeMethodDescriptorProto, jsonEncodeMethodOptions, jsonEncodeMixin, jsonEncodeOneofDescriptorProto, jsonEncodeOneofOptions, jsonEncodeOption, jsonEncodeServiceDescriptorProto, jsonEncodeServiceOptions, jsonEncodeSourceCodeInfo, jsonEncodeSourceContext, jsonEncodeStringValue, jsonEncodeStruct, jsonEncodeTimestamp, jsonEncodeType, jsonEncodeUInt32Value, jsonEncodeUInt64Value, jsonEncodeUninterpretedOption, jsonEncodeValue, unwrapDescriptorProto, unwrapListValue, unwrapValue, wrapDescriptorProto, wrapListValue, wrapValue)

{-| 
This file was automatically generated by
- [`protoc-gen-elm`](https://www.npmjs.com/package/protoc-gen-elm) 4.0.0
- `protoc` 3.19.4
- the following specification files: `google/protobuf/any.proto, google/protobuf/api.proto, google/protobuf/descriptor.proto, google/protobuf/duration.proto, google/protobuf/empty.proto, google/protobuf/field_mask.proto, google/protobuf/source_context.proto, google/protobuf/struct.proto, google/protobuf/timestamp.proto, google/protobuf/type.proto, google/protobuf/wrappers.proto`

To run it, add a dependency via `elm install` on [`elm-protocol-buffers`](https://package.elm-lang.org/packages/eriktim/elm-protocol-buffers/1.2.0) version 1.2.0 or higher.

 Protocol Buffers - Google's data interchange format
 Copyright 2008 Google Inc.  All rights reserved.
 https://developers.google.com/protocol-buffers/

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

     * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following disclaimer
 in the documentation and/or other materials provided with the
 distribution.
     * Neither the name of Google Inc. nor the names of its
 contributors may be used to endorse or promote products derived from
 this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


 Author: kenton@google.com (Kenton Varda)
  Based on original Protocol Buffers design by
  Sanjay Ghemawat, Jeff Dean, and others.

 The messages in this file describe the definitions found in .proto files.
 A valid .proto file can be translated directly to a FileDescriptorProto
 without any other information (e.g. without reading its imports).


 Wrappers for primitive (non-message) types. These types are useful
 for embedding primitives in the `google.protobuf.Any` type and for places
 where we need to distinguish between the absence of a primitive
 typed field and its default value.

 These wrappers have no meaningful use within repeated fields as they lack
 the ability to detect presence on individual elements.
 These wrappers have no meaningful use within a map or a oneof since
 individual entries of a map or fields of a oneof can already detect presence.


@docs Any, Api, BoolValue, BytesValue, DescriptorProto, DescriptorProto_, DoubleValue, Duration, Empty, Enum, EnumDescriptorProto, EnumOptions

@docs EnumValue, EnumValueDescriptorProto, EnumValueOptions, ExtensionRangeOptions, Field, FieldDescriptorProto, FieldMask, FieldOptions

@docs FileDescriptorProto, FileDescriptorSet, FileOptions, FloatValue, GeneratedCodeInfo, Int32Value, Int64Value, ListValue, ListValue_

@docs MessageOptions, Method, MethodDescriptorProto, MethodOptions, Mixin, OneofDescriptorProto, OneofOptions, Option, ServiceDescriptorProto

@docs ServiceOptions, SourceCodeInfo, SourceContext, StringValue, Struct, Timestamp, Type, UInt32Value, UInt64Value, UninterpretedOption, Value

@docs Value_, decodeAny, decodeApi, decodeBoolValue, decodeBytesValue, decodeDescriptorProto, decodeDoubleValue, decodeDuration, decodeEmpty

@docs decodeEnum, decodeEnumDescriptorProto, decodeEnumOptions, decodeEnumValue, decodeEnumValueDescriptorProto, decodeEnumValueOptions

@docs decodeExtensionRangeOptions, decodeField, decodeFieldDescriptorProto, decodeFieldMask, decodeFieldOptions

@docs decodeFileDescriptorProto, decodeFileDescriptorSet, decodeFileOptions, decodeFloatValue, decodeGeneratedCodeInfo, decodeInt32Value

@docs decodeInt64Value, decodeListValue, decodeMessageOptions, decodeMethod, decodeMethodDescriptorProto, decodeMethodOptions, decodeMixin

@docs decodeOneofDescriptorProto, decodeOneofOptions, decodeOption, decodeServiceDescriptorProto, decodeServiceOptions

@docs decodeSourceCodeInfo, decodeSourceContext, decodeStringValue, decodeStruct, decodeTimestamp, decodeType, decodeUInt32Value

@docs decodeUInt64Value, decodeUninterpretedOption, decodeValue, defaultAny, defaultApi, defaultBoolValue, defaultBytesValue

@docs defaultDescriptorProto, defaultDoubleValue, defaultDuration, defaultEmpty, defaultEnum, defaultEnumDescriptorProto

@docs defaultEnumOptions, defaultEnumValue, defaultEnumValueDescriptorProto, defaultEnumValueOptions, defaultExtensionRangeOptions

@docs defaultField, defaultFieldDescriptorProto, defaultFieldMask, defaultFieldOptions, defaultFileDescriptorProto

@docs defaultFileDescriptorSet, defaultFileOptions, defaultFloatValue, defaultGeneratedCodeInfo, defaultInt32Value, defaultInt64Value

@docs defaultListValue, defaultMessageOptions, defaultMethod, defaultMethodDescriptorProto, defaultMethodOptions, defaultMixin

@docs defaultOneofDescriptorProto, defaultOneofOptions, defaultOption, defaultServiceDescriptorProto, defaultServiceOptions

@docs defaultSourceCodeInfo, defaultSourceContext, defaultStringValue, defaultStruct, defaultTimestamp, defaultType, defaultUInt32Value

@docs defaultUInt64Value, defaultUninterpretedOption, defaultValue, encodeAny, encodeApi, encodeBoolValue, encodeBytesValue

@docs encodeDescriptorProto, encodeDoubleValue, encodeDuration, encodeEmpty, encodeEnum, encodeEnumDescriptorProto, encodeEnumOptions

@docs encodeEnumValue, encodeEnumValueDescriptorProto, encodeEnumValueOptions, encodeExtensionRangeOptions, encodeField

@docs encodeFieldDescriptorProto, encodeFieldMask, encodeFieldOptions, encodeFileDescriptorProto, encodeFileDescriptorSet

@docs encodeFileOptions, encodeFloatValue, encodeGeneratedCodeInfo, encodeInt32Value, encodeInt64Value, encodeListValue

@docs encodeMessageOptions, encodeMethod, encodeMethodDescriptorProto, encodeMethodOptions, encodeMixin, encodeOneofDescriptorProto

@docs encodeOneofOptions, encodeOption, encodeServiceDescriptorProto, encodeServiceOptions, encodeSourceCodeInfo, encodeSourceContext

@docs encodeStringValue, encodeStruct, encodeTimestamp, encodeType, encodeUInt32Value, encodeUInt64Value, encodeUninterpretedOption

@docs encodeValue, fieldNumbersAny, fieldNumbersApi, fieldNumbersBoolValue, fieldNumbersBytesValue, fieldNumbersDescriptorProto

@docs fieldNumbersDoubleValue, fieldNumbersDuration, fieldNumbersEmpty, fieldNumbersEnum, fieldNumbersEnumDescriptorProto

@docs fieldNumbersEnumOptions, fieldNumbersEnumValue, fieldNumbersEnumValueDescriptorProto, fieldNumbersEnumValueOptions

@docs fieldNumbersExtensionRangeOptions, fieldNumbersField, fieldNumbersFieldDescriptorProto, fieldNumbersFieldMask

@docs fieldNumbersFieldOptions, fieldNumbersFileDescriptorProto, fieldNumbersFileDescriptorSet, fieldNumbersFileOptions

@docs fieldNumbersFloatValue, fieldNumbersGeneratedCodeInfo, fieldNumbersInt32Value, fieldNumbersInt64Value, fieldNumbersListValue

@docs fieldNumbersMessageOptions, fieldNumbersMethod, fieldNumbersMethodDescriptorProto, fieldNumbersMethodOptions, fieldNumbersMixin

@docs fieldNumbersOneofDescriptorProto, fieldNumbersOneofOptions, fieldNumbersOption, fieldNumbersServiceDescriptorProto

@docs fieldNumbersServiceOptions, fieldNumbersSourceCodeInfo, fieldNumbersSourceContext, fieldNumbersStringValue, fieldNumbersStruct

@docs fieldNumbersTimestamp, fieldNumbersType, fieldNumbersUInt32Value, fieldNumbersUInt64Value, fieldNumbersUninterpretedOption

@docs fieldNumbersValue, jsonDecodeAny, jsonDecodeApi, jsonDecodeBoolValue, jsonDecodeBytesValue, jsonDecodeDescriptorProto

@docs jsonDecodeDoubleValue, jsonDecodeDuration, jsonDecodeEmpty, jsonDecodeEnum, jsonDecodeEnumDescriptorProto, jsonDecodeEnumOptions

@docs jsonDecodeEnumValue, jsonDecodeEnumValueDescriptorProto, jsonDecodeEnumValueOptions, jsonDecodeExtensionRangeOptions

@docs jsonDecodeField, jsonDecodeFieldDescriptorProto, jsonDecodeFieldMask, jsonDecodeFieldOptions, jsonDecodeFileDescriptorProto

@docs jsonDecodeFileDescriptorSet, jsonDecodeFileOptions, jsonDecodeFloatValue, jsonDecodeGeneratedCodeInfo, jsonDecodeInt32Value

@docs jsonDecodeInt64Value, jsonDecodeListValue, jsonDecodeMessageOptions, jsonDecodeMethod, jsonDecodeMethodDescriptorProto

@docs jsonDecodeMethodOptions, jsonDecodeMixin, jsonDecodeOneofDescriptorProto, jsonDecodeOneofOptions, jsonDecodeOption

@docs jsonDecodeServiceDescriptorProto, jsonDecodeServiceOptions, jsonDecodeSourceCodeInfo, jsonDecodeSourceContext

@docs jsonDecodeStringValue, jsonDecodeStruct, jsonDecodeTimestamp, jsonDecodeType, jsonDecodeUInt32Value, jsonDecodeUInt64Value

@docs jsonDecodeUninterpretedOption, jsonDecodeValue, jsonEncodeAny, jsonEncodeApi, jsonEncodeBoolValue, jsonEncodeBytesValue

@docs jsonEncodeDescriptorProto, jsonEncodeDoubleValue, jsonEncodeDuration, jsonEncodeEmpty, jsonEncodeEnum

@docs jsonEncodeEnumDescriptorProto, jsonEncodeEnumOptions, jsonEncodeEnumValue, jsonEncodeEnumValueDescriptorProto

@docs jsonEncodeEnumValueOptions, jsonEncodeExtensionRangeOptions, jsonEncodeField, jsonEncodeFieldDescriptorProto

@docs jsonEncodeFieldMask, jsonEncodeFieldOptions, jsonEncodeFileDescriptorProto, jsonEncodeFileDescriptorSet, jsonEncodeFileOptions

@docs jsonEncodeFloatValue, jsonEncodeGeneratedCodeInfo, jsonEncodeInt32Value, jsonEncodeInt64Value, jsonEncodeListValue

@docs jsonEncodeMessageOptions, jsonEncodeMethod, jsonEncodeMethodDescriptorProto, jsonEncodeMethodOptions, jsonEncodeMixin

@docs jsonEncodeOneofDescriptorProto, jsonEncodeOneofOptions, jsonEncodeOption, jsonEncodeServiceDescriptorProto

@docs jsonEncodeServiceOptions, jsonEncodeSourceCodeInfo, jsonEncodeSourceContext, jsonEncodeStringValue, jsonEncodeStruct

@docs jsonEncodeTimestamp, jsonEncodeType, jsonEncodeUInt32Value, jsonEncodeUInt64Value, jsonEncodeUninterpretedOption, jsonEncodeValue

@docs unwrapDescriptorProto, unwrapListValue, unwrapValue, wrapDescriptorProto, wrapListValue, wrapValue

-}

import Json.Decode
import Json.Encode
import Proto.Google.Protobuf.Internals_
import Protobuf.Decode
import Protobuf.Encode


{-| Declares how to decode a `BytesValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeBytesValue : Json.Decode.Decoder BytesValue
jsonDecodeBytesValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__BytesValue


{-| Encode a `BytesValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeBytesValue : BytesValue -> Json.Encode.Value
jsonEncodeBytesValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__BytesValue


{-| The field numbers for the fields of `BytesValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersBytesValue : { value : Int }
fieldNumbersBytesValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__BytesValue


{-| Default for BytesValue. Should only be used for 'required' decoders as an initial value.

-}
defaultBytesValue : BytesValue
defaultBytesValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__BytesValue


{-| Declares how to decode a `BytesValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeBytesValue : Protobuf.Decode.Decoder BytesValue
decodeBytesValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__BytesValue


{-| Declares how to encode a `BytesValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeBytesValue : BytesValue -> Protobuf.Encode.Encoder
encodeBytesValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__BytesValue


{-|  Wrapper message for `bytes`.

 The JSON representation for `BytesValue` is JSON string.


## Fields

### value

 The bytes value.


-}
type alias BytesValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__BytesValue


{-| Declares how to decode a `StringValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeStringValue : Json.Decode.Decoder StringValue
jsonDecodeStringValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__StringValue


{-| Encode a `StringValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeStringValue : StringValue -> Json.Encode.Value
jsonEncodeStringValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__StringValue


{-| The field numbers for the fields of `StringValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersStringValue : { value : Int }
fieldNumbersStringValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__StringValue


{-| Default for StringValue. Should only be used for 'required' decoders as an initial value.

-}
defaultStringValue : StringValue
defaultStringValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__StringValue


{-| Declares how to decode a `StringValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeStringValue : Protobuf.Decode.Decoder StringValue
decodeStringValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__StringValue


{-| Declares how to encode a `StringValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeStringValue : StringValue -> Protobuf.Encode.Encoder
encodeStringValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__StringValue


{-|  Wrapper message for `string`.

 The JSON representation for `StringValue` is JSON string.


## Fields

### value

 The string value.


-}
type alias StringValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__StringValue


{-| Declares how to decode a `BoolValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeBoolValue : Json.Decode.Decoder BoolValue
jsonDecodeBoolValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__BoolValue


{-| Encode a `BoolValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeBoolValue : BoolValue -> Json.Encode.Value
jsonEncodeBoolValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__BoolValue


{-| The field numbers for the fields of `BoolValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersBoolValue : { value : Int }
fieldNumbersBoolValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__BoolValue


{-| Default for BoolValue. Should only be used for 'required' decoders as an initial value.

-}
defaultBoolValue : BoolValue
defaultBoolValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__BoolValue


{-| Declares how to decode a `BoolValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeBoolValue : Protobuf.Decode.Decoder BoolValue
decodeBoolValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__BoolValue


{-| Declares how to encode a `BoolValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeBoolValue : BoolValue -> Protobuf.Encode.Encoder
encodeBoolValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__BoolValue


{-|  Wrapper message for `bool`.

 The JSON representation for `BoolValue` is JSON `true` and `false`.


## Fields

### value

 The bool value.


-}
type alias BoolValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__BoolValue


{-| Declares how to decode a `UInt32Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeUInt32Value : Json.Decode.Decoder UInt32Value
jsonDecodeUInt32Value =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__UInt32Value


{-| Encode a `UInt32Value` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeUInt32Value : UInt32Value -> Json.Encode.Value
jsonEncodeUInt32Value =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__UInt32Value


{-| The field numbers for the fields of `UInt32Value`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersUInt32Value : { value : Int }
fieldNumbersUInt32Value =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__UInt32Value


{-| Default for UInt32Value. Should only be used for 'required' decoders as an initial value.

-}
defaultUInt32Value : UInt32Value
defaultUInt32Value =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__UInt32Value


{-| Declares how to decode a `UInt32Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeUInt32Value : Protobuf.Decode.Decoder UInt32Value
decodeUInt32Value =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__UInt32Value


{-| Declares how to encode a `UInt32Value` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeUInt32Value : UInt32Value -> Protobuf.Encode.Encoder
encodeUInt32Value =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__UInt32Value


{-|  Wrapper message for `uint32`.

 The JSON representation for `UInt32Value` is JSON number.


## Fields

### value

 The uint32 value.


-}
type alias UInt32Value =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__UInt32Value


{-| Declares how to decode a `Int32Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeInt32Value : Json.Decode.Decoder Int32Value
jsonDecodeInt32Value =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Int32Value


{-| Encode a `Int32Value` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeInt32Value : Int32Value -> Json.Encode.Value
jsonEncodeInt32Value =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Int32Value


{-| The field numbers for the fields of `Int32Value`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersInt32Value : { value : Int }
fieldNumbersInt32Value =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Int32Value


{-| Default for Int32Value. Should only be used for 'required' decoders as an initial value.

-}
defaultInt32Value : Int32Value
defaultInt32Value =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Int32Value


{-| Declares how to decode a `Int32Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeInt32Value : Protobuf.Decode.Decoder Int32Value
decodeInt32Value =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Int32Value


{-| Declares how to encode a `Int32Value` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeInt32Value : Int32Value -> Protobuf.Encode.Encoder
encodeInt32Value =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Int32Value


{-|  Wrapper message for `int32`.

 The JSON representation for `Int32Value` is JSON number.


## Fields

### value

 The int32 value.


-}
type alias Int32Value =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Int32Value


{-| Declares how to decode a `UInt64Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeUInt64Value : Json.Decode.Decoder UInt64Value
jsonDecodeUInt64Value =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__UInt64Value


{-| Encode a `UInt64Value` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeUInt64Value : UInt64Value -> Json.Encode.Value
jsonEncodeUInt64Value =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__UInt64Value


{-| The field numbers for the fields of `UInt64Value`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersUInt64Value : { value : Int }
fieldNumbersUInt64Value =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__UInt64Value


{-| Default for UInt64Value. Should only be used for 'required' decoders as an initial value.

-}
defaultUInt64Value : UInt64Value
defaultUInt64Value =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__UInt64Value


{-| Declares how to decode a `UInt64Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeUInt64Value : Protobuf.Decode.Decoder UInt64Value
decodeUInt64Value =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__UInt64Value


{-| Declares how to encode a `UInt64Value` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeUInt64Value : UInt64Value -> Protobuf.Encode.Encoder
encodeUInt64Value =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__UInt64Value


{-|  Wrapper message for `uint64`.

 The JSON representation for `UInt64Value` is JSON string.


## Fields

### value

 The uint64 value.


-}
type alias UInt64Value =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__UInt64Value


{-| Declares how to decode a `Int64Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeInt64Value : Json.Decode.Decoder Int64Value
jsonDecodeInt64Value =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Int64Value


{-| Encode a `Int64Value` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeInt64Value : Int64Value -> Json.Encode.Value
jsonEncodeInt64Value =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Int64Value


{-| The field numbers for the fields of `Int64Value`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersInt64Value : { value : Int }
fieldNumbersInt64Value =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Int64Value


{-| Default for Int64Value. Should only be used for 'required' decoders as an initial value.

-}
defaultInt64Value : Int64Value
defaultInt64Value =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Int64Value


{-| Declares how to decode a `Int64Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeInt64Value : Protobuf.Decode.Decoder Int64Value
decodeInt64Value =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Int64Value


{-| Declares how to encode a `Int64Value` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeInt64Value : Int64Value -> Protobuf.Encode.Encoder
encodeInt64Value =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Int64Value


{-|  Wrapper message for `int64`.

 The JSON representation for `Int64Value` is JSON string.


## Fields

### value

 The int64 value.


-}
type alias Int64Value =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Int64Value


{-| Declares how to decode a `FloatValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFloatValue : Json.Decode.Decoder FloatValue
jsonDecodeFloatValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FloatValue


{-| Encode a `FloatValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFloatValue : FloatValue -> Json.Encode.Value
jsonEncodeFloatValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FloatValue


{-| The field numbers for the fields of `FloatValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFloatValue : { value : Int }
fieldNumbersFloatValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FloatValue


{-| Default for FloatValue. Should only be used for 'required' decoders as an initial value.

-}
defaultFloatValue : FloatValue
defaultFloatValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FloatValue


{-| Declares how to decode a `FloatValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFloatValue : Protobuf.Decode.Decoder FloatValue
decodeFloatValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FloatValue


{-| Declares how to encode a `FloatValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFloatValue : FloatValue -> Protobuf.Encode.Encoder
encodeFloatValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FloatValue


{-|  Wrapper message for `float`.

 The JSON representation for `FloatValue` is JSON number.


## Fields

### value

 The float value.


-}
type alias FloatValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FloatValue


{-| Declares how to decode a `DoubleValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeDoubleValue : Json.Decode.Decoder DoubleValue
jsonDecodeDoubleValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__DoubleValue


{-| Encode a `DoubleValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeDoubleValue : DoubleValue -> Json.Encode.Value
jsonEncodeDoubleValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__DoubleValue


{-| The field numbers for the fields of `DoubleValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersDoubleValue : { value : Int }
fieldNumbersDoubleValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__DoubleValue


{-| Default for DoubleValue. Should only be used for 'required' decoders as an initial value.

-}
defaultDoubleValue : DoubleValue
defaultDoubleValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__DoubleValue


{-| Declares how to decode a `DoubleValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeDoubleValue : Protobuf.Decode.Decoder DoubleValue
decodeDoubleValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__DoubleValue


{-| Declares how to encode a `DoubleValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeDoubleValue : DoubleValue -> Protobuf.Encode.Encoder
encodeDoubleValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__DoubleValue


{-|  Wrapper message for `double`.

 The JSON representation for `DoubleValue` is JSON number.


## Fields

### value

 The double value.


-}
type alias DoubleValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DoubleValue


{-| Declares how to decode a `Timestamp` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeTimestamp : Json.Decode.Decoder Timestamp
jsonDecodeTimestamp =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Timestamp


{-| Encode a `Timestamp` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeTimestamp : Timestamp -> Json.Encode.Value
jsonEncodeTimestamp =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Timestamp


{-| The field numbers for the fields of `Timestamp`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersTimestamp : { seconds : Int, nanos : Int }
fieldNumbersTimestamp =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Timestamp


{-| Default for Timestamp. Should only be used for 'required' decoders as an initial value.

-}
defaultTimestamp : Timestamp
defaultTimestamp =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Timestamp


{-| Declares how to decode a `Timestamp` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeTimestamp : Protobuf.Decode.Decoder Timestamp
decodeTimestamp =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Timestamp


{-| Declares how to encode a `Timestamp` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeTimestamp : Timestamp -> Protobuf.Encode.Encoder
encodeTimestamp =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Timestamp


{-|  A Timestamp represents a point in time independent of any time zone or local
 calendar, encoded as a count of seconds and fractions of seconds at
 nanosecond resolution. The count is relative to an epoch at UTC midnight on
 January 1, 1970, in the proleptic Gregorian calendar which extends the
 Gregorian calendar backwards to year one.

 All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
 second table is needed for interpretation, using a [24-hour linear
 smear](https://developers.google.com/time/smear).

 The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 restricting to that range, we ensure that we can convert to and from [RFC
 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.

 # Examples

 Example 1: Compute Timestamp from POSIX `time()`.

     Timestamp timestamp;
     timestamp.set_seconds(time(NULL));
     timestamp.set_nanos(0);

 Example 2: Compute Timestamp from POSIX `gettimeofday()`.

     struct timeval tv;
     gettimeofday(&tv, NULL);

     Timestamp timestamp;
     timestamp.set_seconds(tv.tv_sec);
     timestamp.set_nanos(tv.tv_usec * 1000);

 Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.

     FILETIME ft;
     GetSystemTimeAsFileTime(&ft);
     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;

     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
     Timestamp timestamp;
     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));

 Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

     long millis = System.currentTimeMillis();

     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
         .setNanos((int) ((millis % 1000) * 1000000)).build();


 Example 5: Compute Timestamp from Java `Instant.now()`.

     Instant now = Instant.now();

     Timestamp timestamp =
         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
             .setNanos(now.getNano()).build();


 Example 6: Compute Timestamp from current time in Python.

     timestamp = Timestamp()
     timestamp.GetCurrentTime()

 # JSON Mapping

 In JSON format, the Timestamp type is encoded as a string in the
 [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
 where {year} is always expressed using four digits while {month}, {day},
 {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
 is required. A proto3 JSON serializer should always use UTC (as indicated by
 "Z") when printing the Timestamp type and a proto3 JSON parser should be
 able to accept both UTC and other timezones (as indicated by an offset).

 For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
 01:30 UTC on January 15, 2017.

 In JavaScript, one can convert a Date object to this format using the
 standard
 [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 method. In Python, a standard `datetime.datetime` object can be converted
 to this format using
 [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
 the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 the Joda Time's [`ISODateTimeFormat.dateTime()`](
 http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
 ) to obtain a formatter capable of generating timestamps in this format.




## Fields

### seconds

 Represents seconds of UTC time since Unix epoch
 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
 9999-12-31T23:59:59Z inclusive.


### nanos

 Non-negative fractions of a second at nanosecond resolution. Negative
 second values with fractions must still have non-negative nanos values
 that count forward in time. Must be from 0 to 999,999,999
 inclusive.


-}
type alias Timestamp =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Timestamp


{-| Declares how to decode a `ListValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeListValue : Json.Decode.Decoder ListValue
jsonDecodeListValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__ListValue


{-| Encode a `ListValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeListValue : ListValue -> Json.Encode.Value
jsonEncodeListValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__ListValue


{-| Unwrap a `ListValue` from its wrapper `ListValue_.`

-}
unwrapListValue : ListValue_ -> ListValue
unwrapListValue =
    Proto.Google.Protobuf.Internals_.unwrapProto__Google__Protobuf__ListValue


{-| Wrap a `ListValue` into its wrapper `ListValue_.`

-}
wrapListValue : ListValue -> ListValue_
wrapListValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ListValue_


{-| Type wrapper for alias type `ListValue` to avoid unlimited recursion.

For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.

-}
type alias ListValue_ =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ListValue_


{-| The field numbers for the fields of `ListValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersListValue : { values : Int }
fieldNumbersListValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ListValue


{-| Default for ListValue. Should only be used for 'required' decoders as an initial value.

-}
defaultListValue : ListValue
defaultListValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ListValue


{-| Declares how to decode a `ListValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeListValue : Protobuf.Decode.Decoder ListValue
decodeListValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ListValue


{-| Declares how to encode a `ListValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeListValue : ListValue -> Protobuf.Encode.Encoder
encodeListValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ListValue


{-|  `ListValue` is a wrapper around a repeated field of values.

 The JSON representation for `ListValue` is JSON array.


## Fields

### values

 Repeated field of dynamically typed values.


-}
type alias ListValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ListValue


{-| Declares how to decode a `Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeValue : Json.Decode.Decoder Value
jsonDecodeValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Value


{-| Encode a `Value` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeValue : Value -> Json.Encode.Value
jsonEncodeValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Value


{-| Unwrap a `Value` from its wrapper `Value_.`

-}
unwrapValue : Value_ -> Value
unwrapValue =
    Proto.Google.Protobuf.Internals_.unwrapProto__Google__Protobuf__Value


{-| Wrap a `Value` into its wrapper `Value_.`

-}
wrapValue : Value -> Value_
wrapValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Value_


{-| Type wrapper for alias type `Value` to avoid unlimited recursion.

For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.

-}
type alias Value_ =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Value_


{-| The field numbers for the fields of `Value`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersValue : { kind : Proto.Google.Protobuf.Internals_.FieldNumbersProto__Google__Protobuf__Value__Kind__Kind }
fieldNumbersValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Value


{-| Default for Value. Should only be used for 'required' decoders as an initial value.

-}
defaultValue : Value
defaultValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Value


{-| Declares how to decode a `Value` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeValue : Protobuf.Decode.Decoder Value
decodeValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Value


{-| Declares how to encode a `Value` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeValue : Value -> Protobuf.Encode.Encoder
encodeValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Value


{-|  `Value` represents a dynamically typed value which can be either
 null, a number, a string, a boolean, a recursive struct value, or a
 list of values. A producer of value is expected to set one of these
 variants. Absence of any variant indicates an error.

 The JSON representation for `Value` is JSON value.


-}
type alias Value =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Value


{-| Declares how to decode a `Struct` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeStruct : Json.Decode.Decoder Struct
jsonDecodeStruct =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Struct


{-| Encode a `Struct` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeStruct : Struct -> Json.Encode.Value
jsonEncodeStruct =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Struct


{-| The field numbers for the fields of `Struct`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersStruct : { fields : Int }
fieldNumbersStruct =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Struct


{-| Default for Struct. Should only be used for 'required' decoders as an initial value.

-}
defaultStruct : Struct
defaultStruct =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Struct


{-| Declares how to decode a `Struct` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeStruct : Protobuf.Decode.Decoder Struct
decodeStruct =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Struct


{-| Declares how to encode a `Struct` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeStruct : Struct -> Protobuf.Encode.Encoder
encodeStruct =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Struct


{-|  `Struct` represents a structured data value, consisting of fields
 which map to dynamically typed values. In some languages, `Struct`
 might be supported by a native representation. For example, in
 scripting languages like JS a struct is represented as an
 object. The details of that representation are described together
 with the proto support for the language.

 The JSON representation for `Struct` is JSON object.


## Fields

### fields

 Unordered map of dynamically typed values.


-}
type alias Struct =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Struct


{-| Declares how to decode a `FieldMask` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFieldMask : Json.Decode.Decoder FieldMask
jsonDecodeFieldMask =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FieldMask


{-| Encode a `FieldMask` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFieldMask : FieldMask -> Json.Encode.Value
jsonEncodeFieldMask =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FieldMask


{-| The field numbers for the fields of `FieldMask`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFieldMask : { paths : Int }
fieldNumbersFieldMask =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FieldMask


{-| Default for FieldMask. Should only be used for 'required' decoders as an initial value.

-}
defaultFieldMask : FieldMask
defaultFieldMask =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FieldMask


{-| Declares how to decode a `FieldMask` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFieldMask : Protobuf.Decode.Decoder FieldMask
decodeFieldMask =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FieldMask


{-| Declares how to encode a `FieldMask` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFieldMask : FieldMask -> Protobuf.Encode.Encoder
encodeFieldMask =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FieldMask


{-|  `FieldMask` represents a set of symbolic field paths, for example:

     paths: "f.a"
     paths: "f.b.d"

 Here `f` represents a field in some root message, `a` and `b`
 fields in the message found in `f`, and `d` a field found in the
 message in `f.b`.

 Field masks are used to specify a subset of fields that should be
 returned by a get operation or modified by an update operation.
 Field masks also have a custom JSON encoding (see below).

 # Field Masks in Projections

 When used in the context of a projection, a response message or
 sub-message is filtered by the API to only contain those fields as
 specified in the mask. For example, if the mask in the previous
 example is applied to a response message as follows:

     f {
       a : 22
       b {
         d : 1
         x : 2
       }
       y : 13
     }
     z: 8

 The result will not contain specific values for fields x,y and z
 (their value will be set to the default, and omitted in proto text
 output):


     f {
       a : 22
       b {
         d : 1
       }
     }

 A repeated field is not allowed except at the last position of a
 paths string.

 If a FieldMask object is not present in a get operation, the
 operation applies to all fields (as if a FieldMask of all fields
 had been specified).

 Note that a field mask does not necessarily apply to the
 top-level response message. In case of a REST get operation, the
 field mask applies directly to the response, but in case of a REST
 list operation, the mask instead applies to each individual message
 in the returned resource list. In case of a REST custom method,
 other definitions may be used. Where the mask applies will be
 clearly documented together with its declaration in the API.  In
 any case, the effect on the returned resource/resources is required
 behavior for APIs.

 # Field Masks in Update Operations

 A field mask in update operations specifies which fields of the
 targeted resource are going to be updated. The API is required
 to only change the values of the fields as specified in the mask
 and leave the others untouched. If a resource is passed in to
 describe the updated values, the API ignores the values of all
 fields not covered by the mask.

 If a repeated field is specified for an update operation, new values will
 be appended to the existing repeated field in the target resource. Note that
 a repeated field is only allowed in the last position of a `paths` string.

 If a sub-message is specified in the last position of the field mask for an
 update operation, then new value will be merged into the existing sub-message
 in the target resource.

 For example, given the target message:

     f {
       b {
         d: 1
         x: 2
       }
       c: [1]
     }

 And an update message:

     f {
       b {
         d: 10
       }
       c: [2]
     }

 then if the field mask is:

  paths: ["f.b", "f.c"]

 then the result will be:

     f {
       b {
         d: 10
         x: 2
       }
       c: [1, 2]
     }

 An implementation may provide options to override this default behavior for
 repeated and message fields.

 In order to reset a field's value to the default, the field must
 be in the mask and set to the default value in the provided resource.
 Hence, in order to reset all fields of a resource, provide a default
 instance of the resource and set all fields in the mask, or do
 not provide a mask as described below.

 If a field mask is not present on update, the operation applies to
 all fields (as if a field mask of all fields has been specified).
 Note that in the presence of schema evolution, this may mean that
 fields the client does not know and has therefore not filled into
 the request will be reset to their default. If this is unwanted
 behavior, a specific service may require a client to always specify
 a field mask, producing an error if not.

 As with get operations, the location of the resource which
 describes the updated values in the request message depends on the
 operation kind. In any case, the effect of the field mask is
 required to be honored by the API.

 ## Considerations for HTTP REST

 The HTTP kind of an update operation which uses a field mask must
 be set to PATCH instead of PUT in order to satisfy HTTP semantics
 (PUT must only be used for full updates).

 # JSON Encoding of Field Masks

 In JSON, a field mask is encoded as a single string where paths are
 separated by a comma. Fields name in each path are converted
 to/from lower-camel naming conventions.

 As an example, consider the following message declarations:

     message Profile {
       User user = 1;
       Photo photo = 2;
     }
     message User {
       string display_name = 1;
       string address = 2;
     }

 In proto a field mask for `Profile` may look as such:

     mask {
       paths: "user.display_name"
       paths: "photo"
     }

 In JSON, the same mask is represented as below:

     {
       mask: "user.displayName,photo"
     }

 # Field Masks and Oneof Fields

 Field masks treat fields in oneofs just as regular fields. Consider the
 following message:

     message SampleMessage {
       oneof test_oneof {
         string name = 4;
         SubMessage sub_message = 9;
       }
     }

 The field mask can be:

     mask {
       paths: "name"
     }

 Or:

     mask {
       paths: "sub_message"
     }

 Note that oneof type names ("test_oneof" in this case) cannot be used in
 paths.

 ## Field Mask Verification

 The implementation of any API method which has a FieldMask type field in the
 request should verify the included field paths, and return an
 `INVALID_ARGUMENT` error if any path is unmappable.


## Fields

### paths

 The set of field mask paths.


-}
type alias FieldMask =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FieldMask


{-| Declares how to decode a `Empty` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEmpty : Json.Decode.Decoder Empty
jsonDecodeEmpty =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Empty


{-| Encode a `Empty` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEmpty : Empty -> Json.Encode.Value
jsonEncodeEmpty =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Empty


{-| The field numbers for the fields of `Empty`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEmpty : {}
fieldNumbersEmpty =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Empty


{-| Default for Empty. Should only be used for 'required' decoders as an initial value.

-}
defaultEmpty : Empty
defaultEmpty =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Empty


{-| Declares how to decode a `Empty` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEmpty : Protobuf.Decode.Decoder Empty
decodeEmpty =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Empty


{-| Declares how to encode a `Empty` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEmpty : Empty -> Protobuf.Encode.Encoder
encodeEmpty =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Empty


{-|  A generic empty message that you can re-use to avoid defining duplicated
 empty messages in your APIs. A typical example is to use it as the request
 or the response type of an API method. For instance:

     service Foo {
       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
     }

 The JSON representation for `Empty` is empty JSON object `{}`.


-}
type alias Empty =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Empty


{-| Declares how to decode a `Duration` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeDuration : Json.Decode.Decoder Duration
jsonDecodeDuration =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Duration


{-| Encode a `Duration` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeDuration : Duration -> Json.Encode.Value
jsonEncodeDuration =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Duration


{-| The field numbers for the fields of `Duration`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersDuration : { seconds : Int, nanos : Int }
fieldNumbersDuration =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Duration


{-| Default for Duration. Should only be used for 'required' decoders as an initial value.

-}
defaultDuration : Duration
defaultDuration =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Duration


{-| Declares how to decode a `Duration` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeDuration : Protobuf.Decode.Decoder Duration
decodeDuration =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Duration


{-| Declares how to encode a `Duration` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeDuration : Duration -> Protobuf.Encode.Encoder
encodeDuration =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Duration


{-|  A Duration represents a signed, fixed-length span of time represented
 as a count of seconds and fractions of seconds at nanosecond
 resolution. It is independent of any calendar and concepts like "day"
 or "month". It is related to Timestamp in that the difference between
 two Timestamp values is a Duration and it can be added or subtracted
 from a Timestamp. Range is approximately +-10,000 years.

 # Examples

 Example 1: Compute Duration from two Timestamps in pseudo code.

     Timestamp start = ...;
     Timestamp end = ...;
     Duration duration = ...;

     duration.seconds = end.seconds - start.seconds;
     duration.nanos = end.nanos - start.nanos;

     if (duration.seconds < 0 && duration.nanos > 0) {
       duration.seconds += 1;
       duration.nanos -= 1000000000;
     } else if (duration.seconds > 0 && duration.nanos < 0) {
       duration.seconds -= 1;
       duration.nanos += 1000000000;
     }

 Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.

     Timestamp start = ...;
     Duration duration = ...;
     Timestamp end = ...;

     end.seconds = start.seconds + duration.seconds;
     end.nanos = start.nanos + duration.nanos;

     if (end.nanos < 0) {
       end.seconds -= 1;
       end.nanos += 1000000000;
     } else if (end.nanos >= 1000000000) {
       end.seconds += 1;
       end.nanos -= 1000000000;
     }

 Example 3: Compute Duration from datetime.timedelta in Python.

     td = datetime.timedelta(days=3, minutes=10)
     duration = Duration()
     duration.FromTimedelta(td)

 # JSON Mapping

 In JSON format, the Duration type is encoded as a string rather than an
 object, where the string ends in the suffix "s" (indicating seconds) and
 is preceded by the number of seconds, with nanoseconds expressed as
 fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 microsecond should be expressed in JSON format as "3.000001s".




## Fields

### seconds

 Signed seconds of the span of time. Must be from -315,576,000,000
 to +315,576,000,000 inclusive. Note: these bounds are computed from:
 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years


### nanos

 Signed fractions of a second at nanosecond resolution of the span
 of time. Durations less than one second are represented with a 0
 `seconds` field and a positive or negative `nanos` field. For durations
 of one second or more, a non-zero value for the `nanos` field must be
 of the same sign as the `seconds` field. Must be from -999,999,999
 to +999,999,999 inclusive.


-}
type alias Duration =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Duration


{-| Declares how to decode a `GeneratedCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeGeneratedCodeInfo : Json.Decode.Decoder GeneratedCodeInfo
jsonDecodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__GeneratedCodeInfo


{-| Encode a `GeneratedCodeInfo` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeGeneratedCodeInfo : GeneratedCodeInfo -> Json.Encode.Value
jsonEncodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__GeneratedCodeInfo


{-| The field numbers for the fields of `GeneratedCodeInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersGeneratedCodeInfo : { annotation : Int }
fieldNumbersGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__GeneratedCodeInfo


{-| Default for GeneratedCodeInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultGeneratedCodeInfo : GeneratedCodeInfo
defaultGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__GeneratedCodeInfo


{-| Declares how to decode a `GeneratedCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeGeneratedCodeInfo : Protobuf.Decode.Decoder GeneratedCodeInfo
decodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__GeneratedCodeInfo


{-| Declares how to encode a `GeneratedCodeInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeGeneratedCodeInfo : GeneratedCodeInfo -> Protobuf.Encode.Encoder
encodeGeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__GeneratedCodeInfo


{-|  Describes the relationship between generated code and its original source
 file. A GeneratedCodeInfo message is associated with only one generated
 source file, but may contain references to different source .proto files.


## Fields

### annotation

 An Annotation connects some span of text in generated code to an element
 of its generating .proto file.


-}
type alias GeneratedCodeInfo =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__GeneratedCodeInfo


{-| Declares how to decode a `SourceCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeSourceCodeInfo : Json.Decode.Decoder SourceCodeInfo
jsonDecodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__SourceCodeInfo


{-| Encode a `SourceCodeInfo` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeSourceCodeInfo : SourceCodeInfo -> Json.Encode.Value
jsonEncodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__SourceCodeInfo


{-| The field numbers for the fields of `SourceCodeInfo`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersSourceCodeInfo : { location : Int }
fieldNumbersSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__SourceCodeInfo


{-| Default for SourceCodeInfo. Should only be used for 'required' decoders as an initial value.

-}
defaultSourceCodeInfo : SourceCodeInfo
defaultSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__SourceCodeInfo


{-| Declares how to decode a `SourceCodeInfo` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeSourceCodeInfo : Protobuf.Decode.Decoder SourceCodeInfo
decodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__SourceCodeInfo


{-| Declares how to encode a `SourceCodeInfo` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeSourceCodeInfo : SourceCodeInfo -> Protobuf.Encode.Encoder
encodeSourceCodeInfo =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__SourceCodeInfo


{-|  ===================================================================
 Optional source code info


 Encapsulates information about the original source file from which a
 FileDescriptorProto was generated.


## Fields

### location

 A Location identifies a piece of source code in a .proto file which
 corresponds to a particular definition.  This information is intended
 to be useful to IDEs, code indexers, documentation generators, and similar
 tools.

 For example, say we have a file like:
   message Foo {
     optional string foo = 1;
   }
 Let's look at just the field definition:
   optional string foo = 1;
   ^       ^^     ^^  ^  ^^^
   a       bc     de  f  ghi
 We have the following locations:
   span   path               represents
   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).

 Notes:
 - A location may refer to a repeated field itself (i.e. not to any
   particular index within it).  This is used whenever a set of elements are
   logically enclosed in a single code segment.  For example, an entire
   extend block (possibly containing multiple extension definitions) will
   have an outer location whose path refers to the "extensions" repeated
   field without an index.
 - Multiple locations may have the same path.  This happens when a single
   logical declaration is spread out across multiple places.  The most
   obvious example is the "extend" block again -- there may be multiple
   extend blocks in the same scope, each of which will have the same path.
 - A location's span is not always a subset of its parent's span.  For
   example, the "extendee" of an extension declaration appears at the
   beginning of the "extend" block and is shared by all extensions within
   the block.
 - Just because a location's span is a subset of some other location's span
   does not mean that it is a descendant.  For example, a "group" defines
   both a type and a field in a single declaration.  Thus, the locations
   corresponding to the type and field and their components will overlap.
 - Code which tries to interpret locations should probably be designed to
   ignore those that it doesn't understand, as more types of locations could
   be recorded in the future.


-}
type alias SourceCodeInfo =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__SourceCodeInfo


{-| Declares how to decode a `UninterpretedOption` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeUninterpretedOption : Json.Decode.Decoder UninterpretedOption
jsonDecodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__UninterpretedOption


{-| Encode a `UninterpretedOption` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeUninterpretedOption : UninterpretedOption -> Json.Encode.Value
jsonEncodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__UninterpretedOption


{-| The field numbers for the fields of `UninterpretedOption`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersUninterpretedOption :
    { name : Int
    , identifierValue : Int
    , positiveIntValue : Int
    , negativeIntValue : Int
    , doubleValue : Int
    , stringValue : Int
    , aggregateValue : Int
    }
fieldNumbersUninterpretedOption =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__UninterpretedOption


{-| Default for UninterpretedOption. Should only be used for 'required' decoders as an initial value.

-}
defaultUninterpretedOption : UninterpretedOption
defaultUninterpretedOption =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__UninterpretedOption


{-| Declares how to decode a `UninterpretedOption` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeUninterpretedOption : Protobuf.Decode.Decoder UninterpretedOption
decodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__UninterpretedOption


{-| Declares how to encode a `UninterpretedOption` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeUninterpretedOption : UninterpretedOption -> Protobuf.Encode.Encoder
encodeUninterpretedOption =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__UninterpretedOption


{-|  A message representing a option the parser does not recognize. This only
 appears in options protos created by the compiler::Parser class.
 DescriptorPool resolves these when building Descriptor objects. Therefore,
 options protos in descriptor objects (e.g. returned by Descriptor::options(),
 or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 in them.


## Fields

### identifierValue

 The value of the uninterpreted option, in whatever type the tokenizer
 identified it as during parsing. Exactly one of these should be set.


-}
type alias UninterpretedOption =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__UninterpretedOption


{-| Declares how to decode a `MethodOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeMethodOptions : Json.Decode.Decoder MethodOptions
jsonDecodeMethodOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__MethodOptions


{-| Encode a `MethodOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeMethodOptions : MethodOptions -> Json.Encode.Value
jsonEncodeMethodOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__MethodOptions


{-| The field numbers for the fields of `MethodOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersMethodOptions : { deprecated : Int, idempotencyLevel : Int, uninterpretedOption : Int }
fieldNumbersMethodOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MethodOptions


{-| Default for MethodOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultMethodOptions : MethodOptions
defaultMethodOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MethodOptions


{-| Declares how to decode a `MethodOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeMethodOptions : Protobuf.Decode.Decoder MethodOptions
decodeMethodOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MethodOptions


{-| Declares how to encode a `MethodOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeMethodOptions : MethodOptions -> Protobuf.Encode.Encoder
encodeMethodOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MethodOptions


{-| ## Fields

### deprecated

 Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
   framework.  We apologize for hoarding these numbers to ourselves, but
   we were already using them long before we decided to release Protocol
   Buffers.


 Is this method deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the method, or it will be completely ignored; in the very least,
 this is a formalization for deprecating methods.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias MethodOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MethodOptions


{-| Declares how to decode a `ServiceOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeServiceOptions : Json.Decode.Decoder ServiceOptions
jsonDecodeServiceOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__ServiceOptions


{-| Encode a `ServiceOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeServiceOptions : ServiceOptions -> Json.Encode.Value
jsonEncodeServiceOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__ServiceOptions


{-| The field numbers for the fields of `ServiceOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersServiceOptions : { deprecated : Int, uninterpretedOption : Int }
fieldNumbersServiceOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ServiceOptions


{-| Default for ServiceOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultServiceOptions : ServiceOptions
defaultServiceOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ServiceOptions


{-| Declares how to decode a `ServiceOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeServiceOptions : Protobuf.Decode.Decoder ServiceOptions
decodeServiceOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ServiceOptions


{-| Declares how to encode a `ServiceOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeServiceOptions : ServiceOptions -> Protobuf.Encode.Encoder
encodeServiceOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ServiceOptions


{-| ## Fields

### deprecated

 Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
   framework.  We apologize for hoarding these numbers to ourselves, but
   we were already using them long before we decided to release Protocol
   Buffers.


 Is this service deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the service, or it will be completely ignored; in the very least,
 this is a formalization for deprecating services.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias ServiceOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ServiceOptions


{-| Declares how to decode a `EnumValueOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnumValueOptions : Json.Decode.Decoder EnumValueOptions
jsonDecodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__EnumValueOptions


{-| Encode a `EnumValueOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnumValueOptions : EnumValueOptions -> Json.Encode.Value
jsonEncodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__EnumValueOptions


{-| The field numbers for the fields of `EnumValueOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnumValueOptions : { deprecated : Int, uninterpretedOption : Int }
fieldNumbersEnumValueOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumValueOptions


{-| Default for EnumValueOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultEnumValueOptions : EnumValueOptions
defaultEnumValueOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumValueOptions


{-| Declares how to decode a `EnumValueOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnumValueOptions : Protobuf.Decode.Decoder EnumValueOptions
decodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumValueOptions


{-| Declares how to encode a `EnumValueOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnumValueOptions : EnumValueOptions -> Protobuf.Encode.Encoder
encodeEnumValueOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumValueOptions


{-| ## Fields

### deprecated

 Is this enum value deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the enum value, or it will be completely ignored; in the very least,
 this is a formalization for deprecating enum values.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias EnumValueOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumValueOptions


{-| Declares how to decode a `EnumOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnumOptions : Json.Decode.Decoder EnumOptions
jsonDecodeEnumOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__EnumOptions


{-| Encode a `EnumOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnumOptions : EnumOptions -> Json.Encode.Value
jsonEncodeEnumOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__EnumOptions


{-| The field numbers for the fields of `EnumOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnumOptions : { allowAlias : Int, deprecated : Int, uninterpretedOption : Int }
fieldNumbersEnumOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumOptions


{-| Default for EnumOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultEnumOptions : EnumOptions
defaultEnumOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumOptions


{-| Declares how to decode a `EnumOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnumOptions : Protobuf.Decode.Decoder EnumOptions
decodeEnumOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumOptions


{-| Declares how to encode a `EnumOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnumOptions : EnumOptions -> Protobuf.Encode.Encoder
encodeEnumOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumOptions


{-| ## Fields

### allowAlias

 Set this option to true to allow mapping different tag names to the same
 value.


### deprecated

 Is this enum deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the enum, or it will be completely ignored; in the very least, this
 is a formalization for deprecating enums.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias EnumOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumOptions


{-| Declares how to decode a `OneofOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeOneofOptions : Json.Decode.Decoder OneofOptions
jsonDecodeOneofOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__OneofOptions


{-| Encode a `OneofOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeOneofOptions : OneofOptions -> Json.Encode.Value
jsonEncodeOneofOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__OneofOptions


{-| The field numbers for the fields of `OneofOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersOneofOptions : { uninterpretedOption : Int }
fieldNumbersOneofOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__OneofOptions


{-| Default for OneofOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultOneofOptions : OneofOptions
defaultOneofOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__OneofOptions


{-| Declares how to decode a `OneofOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeOneofOptions : Protobuf.Decode.Decoder OneofOptions
decodeOneofOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__OneofOptions


{-| Declares how to encode a `OneofOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeOneofOptions : OneofOptions -> Protobuf.Encode.Encoder
encodeOneofOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__OneofOptions


{-| ## Fields

### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias OneofOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__OneofOptions


{-| Declares how to decode a `FieldOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFieldOptions : Json.Decode.Decoder FieldOptions
jsonDecodeFieldOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FieldOptions


{-| Encode a `FieldOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFieldOptions : FieldOptions -> Json.Encode.Value
jsonEncodeFieldOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FieldOptions


{-| The field numbers for the fields of `FieldOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFieldOptions :
    { ctype : Int, packed : Int, jstype : Int, lazy : Int, deprecated : Int, weak : Int, uninterpretedOption : Int }
fieldNumbersFieldOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FieldOptions


{-| Default for FieldOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultFieldOptions : FieldOptions
defaultFieldOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FieldOptions


{-| Declares how to decode a `FieldOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFieldOptions : Protobuf.Decode.Decoder FieldOptions
decodeFieldOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FieldOptions


{-| Declares how to encode a `FieldOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFieldOptions : FieldOptions -> Protobuf.Encode.Encoder
encodeFieldOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FieldOptions


{-| ## Fields

### ctype

 The ctype option instructs the C++ code generator to use a different
 representation of the field than it normally would.  See the specific
 options below.  This option is not yet implemented in the open source
 release -- sorry, we'll try to include it in a future version!


### packed

 The packed option can be enabled for repeated primitive fields to enable
 a more efficient representation on the wire. Rather than repeatedly
 writing the tag and type for each element, the entire array is encoded as
 a single length-delimited blob. In proto3, only explicit setting it to
 false will avoid using packed encoding.


### jstype

 The jstype option determines the JavaScript type used for values of the
 field.  The option is permitted only for 64 bit integral and fixed types
 (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
 is represented as JavaScript string, which avoids loss of precision that
 can happen when a large value is converted to a floating point JavaScript.
 Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
 use the JavaScript "number" type.  The behavior of the default option
 JS_NORMAL is implementation dependent.

 This option is an enum to permit additional types to be added, e.g.
 goog.math.Integer.


### lazy

 Should this field be parsed lazily?  Lazy applies only to message-type
 fields.  It means that when the outer message is initially parsed, the
 inner message's contents will not be parsed but instead stored in encoded
 form.  The inner message will actually be parsed when it is first accessed.

 This is only a hint.  Implementations are free to choose whether to use
 eager or lazy parsing regardless of the value of this option.  However,
 setting this option true suggests that the protocol author believes that
 using lazy parsing on this field is worth the additional bookkeeping
 overhead typically needed to implement it.

 This option does not affect the public interface of any generated code;
 all method signatures remain the same.  Furthermore, thread-safety of the
 interface is not affected by this option; const methods remain safe to
 call from multiple threads concurrently, while non-const methods continue
 to require exclusive access.


 Note that implementations may choose not to check required fields within
 a lazy sub-message.  That is, calling IsInitialized() on the outer message
 may return true even if the inner message has missing required fields.
 This is necessary because otherwise the inner message would have to be
 parsed in order to perform the check, defeating the purpose of lazy
 parsing.  An implementation which chooses not to check required fields
 must be consistent about it.  That is, for any particular sub-message, the
 implementation must either *always* check its required fields, or *never*
 check its required fields, regardless of whether or not the message has
 been parsed.


### deprecated

 Is this field deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for accessors, or it will be completely ignored; in the very least, this
 is a formalization for deprecating fields.


### weak

 For Google-internal migration only. Do not use.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias FieldOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FieldOptions


{-| Declares how to decode a `MessageOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeMessageOptions : Json.Decode.Decoder MessageOptions
jsonDecodeMessageOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__MessageOptions


{-| Encode a `MessageOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeMessageOptions : MessageOptions -> Json.Encode.Value
jsonEncodeMessageOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__MessageOptions


{-| The field numbers for the fields of `MessageOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersMessageOptions :
    { messageSetWireFormat : Int
    , noStandardDescriptorAccessor : Int
    , deprecated : Int
    , mapEntry : Int
    , uninterpretedOption : Int
    }
fieldNumbersMessageOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MessageOptions


{-| Default for MessageOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultMessageOptions : MessageOptions
defaultMessageOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MessageOptions


{-| Declares how to decode a `MessageOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeMessageOptions : Protobuf.Decode.Decoder MessageOptions
decodeMessageOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MessageOptions


{-| Declares how to encode a `MessageOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeMessageOptions : MessageOptions -> Protobuf.Encode.Encoder
encodeMessageOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MessageOptions


{-| ## Fields

### messageSetWireFormat

 Set true to use the old proto1 MessageSet wire format for extensions.
 This is provided for backwards-compatibility with the MessageSet wire
 format.  You should not use this for any other reason:  It's less
 efficient, has fewer features, and is more complicated.

 The message must be defined exactly as follows:
   message Foo {
     option message_set_wire_format = true;
     extensions 4 to max;
   }
 Note that the message cannot have any defined fields; MessageSets only
 have extensions.

 All extensions of your type must be singular messages; e.g. they cannot
 be int32s, enums, or repeated messages.

 Because this is an option, the above two restrictions are not enforced by
 the protocol compiler.


### noStandardDescriptorAccessor

 Disables the generation of the standard "descriptor()" accessor, which can
 conflict with a field of the same name.  This is meant to make migration
 from proto1 easier; new code should avoid fields named "descriptor".


### deprecated

 Is this message deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for the message, or it will be completely ignored; in the very least,
 this is a formalization for deprecating messages.


### mapEntry

 Whether the message is an automatically generated map entry type for the
 maps field.

 For maps fields:
     map<KeyType, ValueType> map_field = 1;
 The parsed descriptor looks like:
     message MapFieldEntry {
         option map_entry = true;
         optional KeyType key = 1;
         optional ValueType value = 2;
     }
     repeated MapFieldEntry map_field = 1;

 Implementations may choose not to generate the map_entry=true message, but
 use a native map in the target language to hold the keys and values.
 The reflection APIs in such implementations still need to work as
 if the field is a repeated message field.

 NOTE: Do not set the option in .proto files. Always use the maps syntax
 instead. The option should only be implicitly set by the proto compiler
 parser.


### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias MessageOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MessageOptions


{-| Declares how to decode a `FileOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFileOptions : Json.Decode.Decoder FileOptions
jsonDecodeFileOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FileOptions


{-| Encode a `FileOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFileOptions : FileOptions -> Json.Encode.Value
jsonEncodeFileOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FileOptions


{-| The field numbers for the fields of `FileOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFileOptions :
    { javaPackage : Int
    , javaOuterClassname : Int
    , javaMultipleFiles : Int
    , javaGenerateEqualsAndHash : Int
    , javaStringCheckUtf8 : Int
    , optimizeFor : Int
    , goPackage : Int
    , ccGenericServices : Int
    , javaGenericServices : Int
    , pyGenericServices : Int
    , phpGenericServices : Int
    , deprecated : Int
    , ccEnableArenas : Int
    , objcClassPrefix : Int
    , csharpNamespace : Int
    , swiftPrefix : Int
    , phpClassPrefix : Int
    , phpNamespace : Int
    , phpMetadataNamespace : Int
    , rubyPackage : Int
    , uninterpretedOption : Int
    }
fieldNumbersFileOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileOptions


{-| Default for FileOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultFileOptions : FileOptions
defaultFileOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileOptions


{-| Declares how to decode a `FileOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFileOptions : Protobuf.Decode.Decoder FileOptions
decodeFileOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileOptions


{-| Declares how to encode a `FileOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFileOptions : FileOptions -> Protobuf.Encode.Encoder
encodeFileOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileOptions


{-|  ===================================================================
 Options


 Each of the definitions above may have "options" attached.  These are
 just annotations which may cause code to be generated slightly differently
 or may contain hints for code that manipulates protocol messages.

 Clients may define custom options as extensions of the *Options messages.
 These extensions may not yet be known at parsing time, so the parser cannot
 store the values in them.  Instead it stores them in a field in the *Options
 message called uninterpreted_option. This field must have the same name
 across all *Options messages. We then use this field to populate the
 extensions when we build a descriptor, at which point all protos have been
 parsed and so all extensions are known.

 Extension numbers for custom options may be chosen as follows:
 * For options which will only be used within a single application or
   organization, or for experimental options, use field numbers 50000
   through 99999.  It is up to you to ensure that you do not use the
   same number for multiple options.
 * For options which will be published and used publicly by multiple
   independent entities, e-mail protobuf-global-extension-registry@google.com
   to reserve extension numbers. Simply provide your project name (e.g.
   Objective-C plugin) and your project website (if available) -- there's no
   need to explain how you intend to use them. Usually you only need one
   extension number. You can declare multiple options with only one extension
   number by putting them in a sub-message. See the Custom Options section of
   the docs for examples:
   https://developers.google.com/protocol-buffers/docs/proto#options
   If this turns out to be popular, a web service will be set up
   to automatically assign option numbers.


## Fields

### javaPackage

 Sets the Java package where classes generated from this .proto will be
 placed.  By default, the proto package is used, but this is often
 inappropriate because proto packages do not normally start with backwards
 domain names.


### javaOuterClassname

 Controls the name of the wrapper Java class generated for the .proto file.
 That class will always contain the .proto file's getDescriptor() method as
 well as any top-level extensions defined in the .proto file.
 If java_multiple_files is disabled, then all the other classes from the
 .proto file will be nested inside the single wrapper outer class.


### javaMultipleFiles

 If enabled, then the Java code generator will generate a separate .java
 file for each top-level message, enum, and service defined in the .proto
 file.  Thus, these types will *not* be nested inside the wrapper class
 named by java_outer_classname.  However, the wrapper class will still be
 generated to contain the file's getDescriptor() method as well as any
 top-level extensions defined in the file.


### javaGenerateEqualsAndHash

 This option does nothing.


### javaStringCheckUtf8

 If set true, then the Java2 code generator will generate code that
 throws an exception whenever an attempt is made to assign a non-UTF-8
 byte sequence to a string field.
 Message reflection will do the same.
 However, an extension field still accepts non-UTF-8 byte sequences.
 This option has no effect on when used with the lite runtime.


### goPackage

 Sets the Go package where structs generated from this .proto will be
 placed. If omitted, the Go package will be derived from the following:
   - The basename of the package import path, if provided.
   - Otherwise, the package statement in the .proto file, if present.
   - Otherwise, the basename of the .proto file, without extension.


### ccGenericServices

 Should generic services be generated in each language?  "Generic" services
 are not specific to any particular RPC system.  They are generated by the
 main code generators in each language (without additional plugins).
 Generic services were the only kind of service generation supported by
 early versions of google.protobuf.

 Generic services are now considered deprecated in favor of using plugins
 that generate code specific to your particular RPC system.  Therefore,
 these default to false.  Old code which depends on generic services should
 explicitly set them to true.


### deprecated

 Is this file deprecated?
 Depending on the target platform, this can emit Deprecated annotations
 for everything in the file, or it will be completely ignored; in the very
 least, this is a formalization for deprecating files.


### ccEnableArenas

 Enables the use of arenas for the proto messages in this file. This applies
 only to generated classes for C++.


### objcClassPrefix

 Sets the objective c class prefix which is prepended to all objective c
 generated classes from this .proto. There is no default.


### csharpNamespace

 Namespace for generated classes; defaults to the package.


### swiftPrefix

 By default Swift generators will take the proto package and CamelCase it
 replacing '.' with underscore and use that to prefix the types/symbols
 defined. When this options is provided, they will use this value instead
 to prefix the types/symbols defined.


### phpClassPrefix

 Sets the php class prefix which is prepended to all php generated classes
 from this .proto. Default is empty.


### phpNamespace

 Use this option to change the namespace of php generated classes. Default
 is empty. When this option is empty, the package name will be used for
 determining the namespace.


### phpMetadataNamespace

 Use this option to change the namespace of php generated metadata classes.
 Default is empty. When this option is empty, the proto file name will be
 used for determining the namespace.


### rubyPackage

 Use this option to change the package of ruby generated classes. Default
 is empty. When this option is not set, the package name will be used for
 determining the ruby package.


### uninterpretedOption

 The parser stores options it doesn't recognize here.
 See the documentation for the "Options" section above.


-}
type alias FileOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileOptions


{-| Declares how to decode a `MethodDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeMethodDescriptorProto : Json.Decode.Decoder MethodDescriptorProto
jsonDecodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__MethodDescriptorProto


{-| Encode a `MethodDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeMethodDescriptorProto : MethodDescriptorProto -> Json.Encode.Value
jsonEncodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__MethodDescriptorProto


{-| The field numbers for the fields of `MethodDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersMethodDescriptorProto :
    { name : Int, inputType : Int, outputType : Int, options : Int, clientStreaming : Int, serverStreaming : Int }
fieldNumbersMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__MethodDescriptorProto


{-| Default for MethodDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultMethodDescriptorProto : MethodDescriptorProto
defaultMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__MethodDescriptorProto


{-| Declares how to decode a `MethodDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeMethodDescriptorProto : Protobuf.Decode.Decoder MethodDescriptorProto
decodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__MethodDescriptorProto


{-| Declares how to encode a `MethodDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeMethodDescriptorProto : MethodDescriptorProto -> Protobuf.Encode.Encoder
encodeMethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__MethodDescriptorProto


{-|  Describes a method of a service.


## Fields

### inputType

 Input and output type names.  These are resolved in the same way as
 FieldDescriptorProto.type_name, but must refer to a message type.


### clientStreaming

 Identifies if client streams multiple client messages


### serverStreaming

 Identifies if server streams multiple server messages


-}
type alias MethodDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__MethodDescriptorProto


{-| Declares how to decode a `ServiceDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeServiceDescriptorProto : Json.Decode.Decoder ServiceDescriptorProto
jsonDecodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__ServiceDescriptorProto


{-| Encode a `ServiceDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeServiceDescriptorProto : ServiceDescriptorProto -> Json.Encode.Value
jsonEncodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__ServiceDescriptorProto


{-| The field numbers for the fields of `ServiceDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersServiceDescriptorProto : { name : Int, method : Int, options : Int }
fieldNumbersServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ServiceDescriptorProto


{-| Default for ServiceDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultServiceDescriptorProto : ServiceDescriptorProto
defaultServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ServiceDescriptorProto


{-| Declares how to decode a `ServiceDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeServiceDescriptorProto : Protobuf.Decode.Decoder ServiceDescriptorProto
decodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ServiceDescriptorProto


{-| Declares how to encode a `ServiceDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeServiceDescriptorProto : ServiceDescriptorProto -> Protobuf.Encode.Encoder
encodeServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ServiceDescriptorProto


{-|  Describes a service.


-}
type alias ServiceDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ServiceDescriptorProto


{-| Declares how to decode a `EnumValueDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnumValueDescriptorProto : Json.Decode.Decoder EnumValueDescriptorProto
jsonDecodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__EnumValueDescriptorProto


{-| Encode a `EnumValueDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnumValueDescriptorProto : EnumValueDescriptorProto -> Json.Encode.Value
jsonEncodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__EnumValueDescriptorProto


{-| The field numbers for the fields of `EnumValueDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnumValueDescriptorProto : { name : Int, number : Int, options : Int }
fieldNumbersEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumValueDescriptorProto


{-| Default for EnumValueDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultEnumValueDescriptorProto : EnumValueDescriptorProto
defaultEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumValueDescriptorProto


{-| Declares how to decode a `EnumValueDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnumValueDescriptorProto : Protobuf.Decode.Decoder EnumValueDescriptorProto
decodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumValueDescriptorProto


{-| Declares how to encode a `EnumValueDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnumValueDescriptorProto : EnumValueDescriptorProto -> Protobuf.Encode.Encoder
encodeEnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumValueDescriptorProto


{-|  Describes a value within an enum.


-}
type alias EnumValueDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumValueDescriptorProto


{-| Declares how to decode a `EnumDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnumDescriptorProto : Json.Decode.Decoder EnumDescriptorProto
jsonDecodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__EnumDescriptorProto


{-| Encode a `EnumDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnumDescriptorProto : EnumDescriptorProto -> Json.Encode.Value
jsonEncodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__EnumDescriptorProto


{-| The field numbers for the fields of `EnumDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnumDescriptorProto : { name : Int, value : Int, options : Int, reservedRange : Int, reservedName : Int }
fieldNumbersEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumDescriptorProto


{-| Default for EnumDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultEnumDescriptorProto : EnumDescriptorProto
defaultEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumDescriptorProto


{-| Declares how to decode a `EnumDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnumDescriptorProto : Protobuf.Decode.Decoder EnumDescriptorProto
decodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumDescriptorProto


{-| Declares how to encode a `EnumDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnumDescriptorProto : EnumDescriptorProto -> Protobuf.Encode.Encoder
encodeEnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumDescriptorProto


{-|  Describes an enum type.


## Fields

### reservedRange

 Range of reserved numeric values. Reserved numeric values may not be used
 by enum values in the same enum declaration. Reserved ranges may not
 overlap.


### reservedName

 Reserved enum value names, which may not be reused. A given name may only
 be reserved once.


-}
type alias EnumDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumDescriptorProto


{-| Declares how to decode a `OneofDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeOneofDescriptorProto : Json.Decode.Decoder OneofDescriptorProto
jsonDecodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__OneofDescriptorProto


{-| Encode a `OneofDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeOneofDescriptorProto : OneofDescriptorProto -> Json.Encode.Value
jsonEncodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__OneofDescriptorProto


{-| The field numbers for the fields of `OneofDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersOneofDescriptorProto : { name : Int, options : Int }
fieldNumbersOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__OneofDescriptorProto


{-| Default for OneofDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultOneofDescriptorProto : OneofDescriptorProto
defaultOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__OneofDescriptorProto


{-| Declares how to decode a `OneofDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeOneofDescriptorProto : Protobuf.Decode.Decoder OneofDescriptorProto
decodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__OneofDescriptorProto


{-| Declares how to encode a `OneofDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeOneofDescriptorProto : OneofDescriptorProto -> Protobuf.Encode.Encoder
encodeOneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__OneofDescriptorProto


{-|  Describes a oneof.


-}
type alias OneofDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__OneofDescriptorProto


{-| Declares how to decode a `FieldDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFieldDescriptorProto : Json.Decode.Decoder FieldDescriptorProto
jsonDecodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FieldDescriptorProto


{-| Encode a `FieldDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFieldDescriptorProto : FieldDescriptorProto -> Json.Encode.Value
jsonEncodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FieldDescriptorProto


{-| The field numbers for the fields of `FieldDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFieldDescriptorProto :
    { name : Int
    , number : Int
    , label : Int
    , type_ : Int
    , typeName : Int
    , extendee : Int
    , defaultValue : Int
    , oneofIndex : Int
    , jsonName : Int
    , options : Int
    , proto3Optional : Int
    }
fieldNumbersFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FieldDescriptorProto


{-| Default for FieldDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultFieldDescriptorProto : FieldDescriptorProto
defaultFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FieldDescriptorProto


{-| Declares how to decode a `FieldDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFieldDescriptorProto : Protobuf.Decode.Decoder FieldDescriptorProto
decodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FieldDescriptorProto


{-| Declares how to encode a `FieldDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFieldDescriptorProto : FieldDescriptorProto -> Protobuf.Encode.Encoder
encodeFieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FieldDescriptorProto


{-|  Describes a field within a message.


## Fields

### type_

 If type_name is set, this need not be set.  If both this and type_name
 are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.


### typeName

 For message and enum types, this is the name of the type.  If the name
 starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
 rules are used to find the type (i.e. first the nested types within this
 message are searched, then within the parent, on up to the root
 namespace).


### extendee

 For extensions, this is the name of the type being extended.  It is
 resolved in the same manner as type_name.


### defaultValue

 For numeric types, contains the original text representation of the value.
 For booleans, "true" or "false".
 For strings, contains the default text contents (not escaped in any way).
 For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
 TODO(kenton):  Base-64 encode?


### oneofIndex

 If set, gives the index of a oneof in the containing type's oneof_decl
 list.  This field is a member of that oneof.


### jsonName

 JSON name of this field. The value is set by protocol compiler. If the
 user has set a "json_name" option on this field, that option's value
 will be used. Otherwise, it's deduced from the field's name by converting
 it to camelCase.


### proto3Optional

 If true, this is a proto3 "optional". When a proto3 field is optional, it
 tracks presence regardless of field type.

 When proto3_optional is true, this field must be belong to a oneof to
 signal to old proto3 clients that presence is tracked for this field. This
 oneof is known as a "synthetic" oneof, and this field must be its sole
 member (each proto3 optional field gets its own synthetic oneof). Synthetic
 oneofs exist in the descriptor only, and do not generate any API. Synthetic
 oneofs must be ordered after all "real" oneofs.

 For message fields, proto3_optional doesn't create any semantic change,
 since non-repeated message fields always track presence. However it still
 indicates the semantic detail of whether the user wrote "optional" or not.
 This can be useful for round-tripping the .proto file. For consistency we
 give message fields a synthetic oneof also, even though it is not required
 to track presence. This is especially important because the parser can't
 tell if a field is a message or an enum, so it must always create a
 synthetic oneof.

 Proto2 optional fields do not set this flag, because they already indicate
 optional with `LABEL_OPTIONAL`.


-}
type alias FieldDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FieldDescriptorProto


{-| Declares how to decode a `ExtensionRangeOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeExtensionRangeOptions : Json.Decode.Decoder ExtensionRangeOptions
jsonDecodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__ExtensionRangeOptions


{-| Encode a `ExtensionRangeOptions` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeExtensionRangeOptions : ExtensionRangeOptions -> Json.Encode.Value
jsonEncodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__ExtensionRangeOptions


{-| The field numbers for the fields of `ExtensionRangeOptions`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersExtensionRangeOptions : { uninterpretedOption : Int }
fieldNumbersExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__ExtensionRangeOptions


{-| Default for ExtensionRangeOptions. Should only be used for 'required' decoders as an initial value.

-}
defaultExtensionRangeOptions : ExtensionRangeOptions
defaultExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__ExtensionRangeOptions


{-| Declares how to decode a `ExtensionRangeOptions` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeExtensionRangeOptions : Protobuf.Decode.Decoder ExtensionRangeOptions
decodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__ExtensionRangeOptions


{-| Declares how to encode a `ExtensionRangeOptions` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeExtensionRangeOptions : ExtensionRangeOptions -> Protobuf.Encode.Encoder
encodeExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__ExtensionRangeOptions


{-| ## Fields

### uninterpretedOption

 The parser stores options it doesn't recognize here. See above.


-}
type alias ExtensionRangeOptions =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__ExtensionRangeOptions


{-| Declares how to decode a `DescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeDescriptorProto : Json.Decode.Decoder DescriptorProto
jsonDecodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__DescriptorProto


{-| Encode a `DescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeDescriptorProto : DescriptorProto -> Json.Encode.Value
jsonEncodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__DescriptorProto


{-| Unwrap a `DescriptorProto` from its wrapper `DescriptorProto_.`

-}
unwrapDescriptorProto : DescriptorProto_ -> DescriptorProto
unwrapDescriptorProto =
    Proto.Google.Protobuf.Internals_.unwrapProto__Google__Protobuf__DescriptorProto


{-| Wrap a `DescriptorProto` into its wrapper `DescriptorProto_.`

-}
wrapDescriptorProto : DescriptorProto -> DescriptorProto_
wrapDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto_


{-| Type wrapper for alias type `DescriptorProto` to avoid unlimited recursion.

For a more in-depth explanation why we need this, read this: https://github.com/elm/compiler/blob/master/hints/recursive-alias.md.

-}
type alias DescriptorProto_ =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto_


{-| The field numbers for the fields of `DescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersDescriptorProto :
    { name : Int
    , field : Int
    , extension : Int
    , nestedType : Int
    , enumType : Int
    , extensionRange : Int
    , oneofDecl : Int
    , options : Int
    , reservedRange : Int
    , reservedName : Int
    }
fieldNumbersDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__DescriptorProto


{-| Default for DescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultDescriptorProto : DescriptorProto
defaultDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__DescriptorProto


{-| Declares how to decode a `DescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeDescriptorProto : Protobuf.Decode.Decoder DescriptorProto
decodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__DescriptorProto


{-| Declares how to encode a `DescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeDescriptorProto : DescriptorProto -> Protobuf.Encode.Encoder
encodeDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__DescriptorProto


{-|  Describes a message type.


## Fields

### reservedName

 Reserved field names, which may not be used by fields in the same message.
 A given name may only be reserved once.


-}
type alias DescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__DescriptorProto


{-| Declares how to decode a `FileDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFileDescriptorProto : Json.Decode.Decoder FileDescriptorProto
jsonDecodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FileDescriptorProto


{-| Encode a `FileDescriptorProto` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFileDescriptorProto : FileDescriptorProto -> Json.Encode.Value
jsonEncodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FileDescriptorProto


{-| The field numbers for the fields of `FileDescriptorProto`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFileDescriptorProto :
    { name : Int
    , package : Int
    , dependency : Int
    , publicDependency : Int
    , weakDependency : Int
    , messageType : Int
    , enumType : Int
    , service : Int
    , extension : Int
    , options : Int
    , sourceCodeInfo : Int
    , syntax : Int
    }
fieldNumbersFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileDescriptorProto


{-| Default for FileDescriptorProto. Should only be used for 'required' decoders as an initial value.

-}
defaultFileDescriptorProto : FileDescriptorProto
defaultFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileDescriptorProto


{-| Declares how to decode a `FileDescriptorProto` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFileDescriptorProto : Protobuf.Decode.Decoder FileDescriptorProto
decodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileDescriptorProto


{-| Declares how to encode a `FileDescriptorProto` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFileDescriptorProto : FileDescriptorProto -> Protobuf.Encode.Encoder
encodeFileDescriptorProto =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileDescriptorProto


{-|  Describes a complete .proto file.


## Fields

### name

 file name, relative to root of source tree


### package

 e.g. "foo", "foo.bar", etc.


### dependency

 Names of files imported by this file.


### publicDependency

 Indexes of the public imported files in the dependency list above.


### weakDependency

 Indexes of the weak imported files in the dependency list.
 For Google-internal migration only. Do not use.


### messageType

 All top-level definitions in this file.


### sourceCodeInfo

 This field contains optional information about the original source code.
 You may safely remove this entire field without harming runtime
 functionality of the descriptors -- the information is needed only by
 development tools.


### syntax

 The syntax of the proto file.
 The supported values are "proto2" and "proto3".


-}
type alias FileDescriptorProto =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileDescriptorProto


{-| Declares how to decode a `FileDescriptorSet` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeFileDescriptorSet : Json.Decode.Decoder FileDescriptorSet
jsonDecodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__FileDescriptorSet


{-| Encode a `FileDescriptorSet` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeFileDescriptorSet : FileDescriptorSet -> Json.Encode.Value
jsonEncodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__FileDescriptorSet


{-| The field numbers for the fields of `FileDescriptorSet`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersFileDescriptorSet : { file : Int }
fieldNumbersFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__FileDescriptorSet


{-| Default for FileDescriptorSet. Should only be used for 'required' decoders as an initial value.

-}
defaultFileDescriptorSet : FileDescriptorSet
defaultFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__FileDescriptorSet


{-| Declares how to decode a `FileDescriptorSet` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeFileDescriptorSet : Protobuf.Decode.Decoder FileDescriptorSet
decodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__FileDescriptorSet


{-| Declares how to encode a `FileDescriptorSet` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeFileDescriptorSet : FileDescriptorSet -> Protobuf.Encode.Encoder
encodeFileDescriptorSet =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__FileDescriptorSet


{-|  The protocol compiler can output a FileDescriptorSet containing the .proto
 files it parses.


-}
type alias FileDescriptorSet =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__FileDescriptorSet


{-| Declares how to decode a `Mixin` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeMixin : Json.Decode.Decoder Mixin
jsonDecodeMixin =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Mixin


{-| Encode a `Mixin` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeMixin : Mixin -> Json.Encode.Value
jsonEncodeMixin =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Mixin


{-| The field numbers for the fields of `Mixin`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersMixin : { name : Int, root : Int }
fieldNumbersMixin =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Mixin


{-| Default for Mixin. Should only be used for 'required' decoders as an initial value.

-}
defaultMixin : Mixin
defaultMixin =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Mixin


{-| Declares how to decode a `Mixin` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeMixin : Protobuf.Decode.Decoder Mixin
decodeMixin =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Mixin


{-| Declares how to encode a `Mixin` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeMixin : Mixin -> Protobuf.Encode.Encoder
encodeMixin =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Mixin


{-|  Declares an API Interface to be included in this interface. The including
 interface must redeclare all the methods from the included interface, but
 documentation and options are inherited as follows:

 - If after comment and whitespace stripping, the documentation
   string of the redeclared method is empty, it will be inherited
   from the original method.

 - Each annotation belonging to the service config (http,
   visibility) which is not set in the redeclared method will be
   inherited.

 - If an http annotation is inherited, the path pattern will be
   modified as follows. Any version prefix will be replaced by the
   version of the including interface plus the [root][] path if
   specified.

 Example of a simple mixin:

     package google.acl.v1;
     service AccessControl {
       // Get the underlying ACL object.
       rpc GetAcl(GetAclRequest) returns (Acl) {
         option (google.api.http).get = "/v1/{resource=**}:getAcl";
       }
     }

     package google.storage.v2;
     service Storage {
       rpc GetAcl(GetAclRequest) returns (Acl);

       // Get a data record.
       rpc GetData(GetDataRequest) returns (Data) {
         option (google.api.http).get = "/v2/{resource=**}";
       }
     }

 Example of a mixin configuration:

     apis:
     - name: google.storage.v2.Storage
       mixins:
       - name: google.acl.v1.AccessControl

 The mixin construct implies that all methods in `AccessControl` are
 also declared with same name and request/response types in
 `Storage`. A documentation generator or annotation processor will
 see the effective `Storage.GetAcl` method after inheriting
 documentation and annotations as follows:

     service Storage {
       // Get the underlying ACL object.
       rpc GetAcl(GetAclRequest) returns (Acl) {
         option (google.api.http).get = "/v2/{resource=**}:getAcl";
       }
       ...
     }

 Note how the version in the path pattern changed from `v1` to `v2`.

 If the `root` field in the mixin is specified, it should be a
 relative path under which inherited HTTP paths are placed. Example:

     apis:
     - name: google.storage.v2.Storage
       mixins:
       - name: google.acl.v1.AccessControl
         root: acls

 This implies the following inherited HTTP annotation:

     service Storage {
       // Get the underlying ACL object.
       rpc GetAcl(GetAclRequest) returns (Acl) {
         option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
       }
       ...
     }


## Fields

### name

 The fully qualified name of the interface which is included.


### root

 If non-empty specifies a path under which inherited HTTP paths
 are rooted.


-}
type alias Mixin =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Mixin


{-| Declares how to decode a `Method` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeMethod : Json.Decode.Decoder Method
jsonDecodeMethod =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Method


{-| Encode a `Method` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeMethod : Method -> Json.Encode.Value
jsonEncodeMethod =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Method


{-| The field numbers for the fields of `Method`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersMethod :
    { name : Int
    , requestTypeUrl : Int
    , requestStreaming : Int
    , responseTypeUrl : Int
    , responseStreaming : Int
    , options : Int
    , syntax : Int
    }
fieldNumbersMethod =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Method


{-| Default for Method. Should only be used for 'required' decoders as an initial value.

-}
defaultMethod : Method
defaultMethod =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Method


{-| Declares how to decode a `Method` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeMethod : Protobuf.Decode.Decoder Method
decodeMethod =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Method


{-| Declares how to encode a `Method` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeMethod : Method -> Protobuf.Encode.Encoder
encodeMethod =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Method


{-|  Method represents a method of an API interface.


## Fields

### name

 The simple name of this method.


### requestTypeUrl

 A URL of the input message type.


### requestStreaming

 If true, the request is streamed.


### responseTypeUrl

 The URL of the output message type.


### responseStreaming

 If true, the response is streamed.


### options

 Any metadata attached to the method.


### syntax

 The source syntax of this method.


-}
type alias Method =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Method


{-| Declares how to decode a `Api` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeApi : Json.Decode.Decoder Api
jsonDecodeApi =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Api


{-| Encode a `Api` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeApi : Api -> Json.Encode.Value
jsonEncodeApi =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Api


{-| The field numbers for the fields of `Api`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersApi :
    { name : Int, methods : Int, options : Int, version : Int, sourceContext : Int, mixins : Int, syntax : Int }
fieldNumbersApi =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Api


{-| Default for Api. Should only be used for 'required' decoders as an initial value.

-}
defaultApi : Api
defaultApi =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Api


{-| Declares how to decode a `Api` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeApi : Protobuf.Decode.Decoder Api
decodeApi =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Api


{-| Declares how to encode a `Api` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeApi : Api -> Protobuf.Encode.Encoder
encodeApi =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Api


{-|  Api is a light-weight descriptor for an API Interface.

 Interfaces are also described as "protocol buffer services" in some contexts,
 such as by the "service" keyword in a .proto file, but they are different
 from API Services, which represent a concrete implementation of an interface
 as opposed to simply a description of methods and bindings. They are also
 sometimes simply referred to as "APIs" in other contexts, such as the name of
 this message itself. See https://cloud.google.com/apis/design/glossary for
 detailed terminology.


## Fields

### name

 The fully qualified name of this interface, including package name
 followed by the interface's simple name.


### methods

 The methods of this interface, in unspecified order.


### options

 Any metadata attached to the interface.


### version

 A version string for this interface. If specified, must have the form
 `major-version.minor-version`, as in `1.10`. If the minor version is
 omitted, it defaults to zero. If the entire version field is empty, the
 major version is derived from the package name, as outlined below. If the
 field is not empty, the version in the package name will be verified to be
 consistent with what is provided here.

 The versioning schema uses [semantic
 versioning](http://semver.org) where the major version number
 indicates a breaking change and the minor version an additive,
 non-breaking change. Both version numbers are signals to users
 what to expect from different versions, and should be carefully
 chosen based on the product plan.

 The major version is also reflected in the package name of the
 interface, which must end in `v<major-version>`, as in
 `google.feature.v1`. For major versions 0 and 1, the suffix can
 be omitted. Zero major versions must only be used for
 experimental, non-GA interfaces.




### sourceContext

 Source context for the protocol buffer service represented by this
 message.


### mixins

 Included interfaces. See [Mixin][].


### syntax

 The source syntax of the service.


-}
type alias Api =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Api


{-| Declares how to decode a `Option` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeOption : Json.Decode.Decoder Option
jsonDecodeOption =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Option


{-| Encode a `Option` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeOption : Option -> Json.Encode.Value
jsonEncodeOption =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Option


{-| The field numbers for the fields of `Option`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersOption : { name : Int, value : Int }
fieldNumbersOption =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Option


{-| Default for Option. Should only be used for 'required' decoders as an initial value.

-}
defaultOption : Option
defaultOption =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Option


{-| Declares how to decode a `Option` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeOption : Protobuf.Decode.Decoder Option
decodeOption =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Option


{-| Declares how to encode a `Option` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeOption : Option -> Protobuf.Encode.Encoder
encodeOption =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Option


{-|  A protocol buffer option, which can be attached to a message, field,
 enumeration, etc.


## Fields

### name

 The option's name. For protobuf built-in options (options defined in
 descriptor.proto), this is the short name. For example, `"map_entry"`.
 For custom options, it should be the fully-qualified name. For example,
 `"google.api.http"`.


### value

 The option's value packed in an Any message. If the value is a primitive,
 the corresponding wrapper type defined in google/protobuf/wrappers.proto
 should be used. If the value is an enum, it should be stored as an int32
 value using the google.protobuf.Int32Value type.


-}
type alias Option =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Option


{-| Declares how to decode a `EnumValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnumValue : Json.Decode.Decoder EnumValue
jsonDecodeEnumValue =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__EnumValue


{-| Encode a `EnumValue` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnumValue : EnumValue -> Json.Encode.Value
jsonEncodeEnumValue =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__EnumValue


{-| The field numbers for the fields of `EnumValue`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnumValue : { name : Int, number : Int, options : Int }
fieldNumbersEnumValue =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__EnumValue


{-| Default for EnumValue. Should only be used for 'required' decoders as an initial value.

-}
defaultEnumValue : EnumValue
defaultEnumValue =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__EnumValue


{-| Declares how to decode a `EnumValue` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnumValue : Protobuf.Decode.Decoder EnumValue
decodeEnumValue =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__EnumValue


{-| Declares how to encode a `EnumValue` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnumValue : EnumValue -> Protobuf.Encode.Encoder
encodeEnumValue =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__EnumValue


{-|  Enum value definition.


## Fields

### name

 Enum value name.


### number

 Enum value number.


### options

 Protocol buffer options.


-}
type alias EnumValue =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__EnumValue


{-| Declares how to decode a `Enum` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeEnum : Json.Decode.Decoder Enum
jsonDecodeEnum =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Enum


{-| Encode a `Enum` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeEnum : Enum -> Json.Encode.Value
jsonEncodeEnum =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Enum


{-| The field numbers for the fields of `Enum`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersEnum : { name : Int, enumvalue : Int, options : Int, sourceContext : Int, syntax : Int }
fieldNumbersEnum =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Enum


{-| Default for Enum. Should only be used for 'required' decoders as an initial value.

-}
defaultEnum : Enum
defaultEnum =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Enum


{-| Declares how to decode a `Enum` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeEnum : Protobuf.Decode.Decoder Enum
decodeEnum =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Enum


{-| Declares how to encode a `Enum` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeEnum : Enum -> Protobuf.Encode.Encoder
encodeEnum =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Enum


{-|  Enum type definition.


## Fields

### name

 Enum type name.


### enumvalue

 Enum value definitions.


### options

 Protocol buffer options.


### sourceContext

 The source context.


### syntax

 The source syntax.


-}
type alias Enum =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Enum


{-| Declares how to decode a `Field` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeField : Json.Decode.Decoder Field
jsonDecodeField =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Field


{-| Encode a `Field` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeField : Field -> Json.Encode.Value
jsonEncodeField =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Field


{-| The field numbers for the fields of `Field`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersField :
    { kind : Int
    , cardinality : Int
    , number : Int
    , name : Int
    , typeUrl : Int
    , oneofIndex : Int
    , packed : Int
    , options : Int
    , jsonName : Int
    , defaultValue : Int
    }
fieldNumbersField =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Field


{-| Default for Field. Should only be used for 'required' decoders as an initial value.

-}
defaultField : Field
defaultField =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Field


{-| Declares how to decode a `Field` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeField : Protobuf.Decode.Decoder Field
decodeField =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Field


{-| Declares how to encode a `Field` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeField : Field -> Protobuf.Encode.Encoder
encodeField =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Field


{-|  A single field of a message type.


## Fields

### kind

 The field type.


### cardinality

 The field cardinality.


### number

 The field number.


### name

 The field name.


### typeUrl

 The field type URL, without the scheme, for message or enumeration
 types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.


### oneofIndex

 The index of the field type in `Type.oneofs`, for message or enumeration
 types. The first type has index 1; zero means the type is not in the list.


### packed

 Whether to use alternative packed wire representation.


### options

 The protocol buffer options.


### jsonName

 The field JSON name.


### defaultValue

 The string value of the default value of this field. Proto2 syntax only.


-}
type alias Field =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Field


{-| Declares how to decode a `Type` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeType : Json.Decode.Decoder Type
jsonDecodeType =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Type


{-| Encode a `Type` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeType : Type -> Json.Encode.Value
jsonEncodeType =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Type


{-| The field numbers for the fields of `Type`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersType : { name : Int, fields : Int, oneofs : Int, options : Int, sourceContext : Int, syntax : Int }
fieldNumbersType =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Type


{-| Default for Type. Should only be used for 'required' decoders as an initial value.

-}
defaultType : Type
defaultType =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Type


{-| Declares how to decode a `Type` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeType : Protobuf.Decode.Decoder Type
decodeType =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Type


{-| Declares how to encode a `Type` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeType : Type -> Protobuf.Encode.Encoder
encodeType =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Type


{-|  A protocol buffer message type.


## Fields

### name

 The fully qualified message name.


### fields

 The list of fields.


### oneofs

 The list of types appearing in `oneof` definitions in this type.


### options

 The protocol buffer options.


### sourceContext

 The source context.


### syntax

 The source syntax.


-}
type alias Type =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Type


{-| Declares how to decode a `SourceContext` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeSourceContext : Json.Decode.Decoder SourceContext
jsonDecodeSourceContext =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__SourceContext


{-| Encode a `SourceContext` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeSourceContext : SourceContext -> Json.Encode.Value
jsonEncodeSourceContext =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__SourceContext


{-| The field numbers for the fields of `SourceContext`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersSourceContext : { fileName : Int }
fieldNumbersSourceContext =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__SourceContext


{-| Default for SourceContext. Should only be used for 'required' decoders as an initial value.

-}
defaultSourceContext : SourceContext
defaultSourceContext =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__SourceContext


{-| Declares how to decode a `SourceContext` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeSourceContext : Protobuf.Decode.Decoder SourceContext
decodeSourceContext =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__SourceContext


{-| Declares how to encode a `SourceContext` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeSourceContext : SourceContext -> Protobuf.Encode.Encoder
encodeSourceContext =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__SourceContext


{-|  `SourceContext` represents information about the source of a
 protobuf element, like the file in which it is defined.


## Fields

### fileName

 The path-qualified name of the .proto file that contained the associated
 protobuf element.  For example: `"google/protobuf/source_context.proto"`.


-}
type alias SourceContext =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__SourceContext


{-| Declares how to decode a `Any` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
jsonDecodeAny : Json.Decode.Decoder Any
jsonDecodeAny =
    Proto.Google.Protobuf.Internals_.jsonDecodeProto__Google__Protobuf__Any


{-| Encode a `Any` to JSON. Uses the canonical encoding described here: https://protobuf.dev/programming-guides/proto3/#json

-}
jsonEncodeAny : Any -> Json.Encode.Value
jsonEncodeAny =
    Proto.Google.Protobuf.Internals_.jsonEncodeProto__Google__Protobuf__Any


{-| The field numbers for the fields of `Any`. This is mostly useful for internals, like documentation generation.

-}
fieldNumbersAny : { typeUrl : Int, value : Int }
fieldNumbersAny =
    Proto.Google.Protobuf.Internals_.fieldNumbersProto__Google__Protobuf__Any


{-| Default for Any. Should only be used for 'required' decoders as an initial value.

-}
defaultAny : Any
defaultAny =
    Proto.Google.Protobuf.Internals_.defaultProto__Google__Protobuf__Any


{-| Declares how to decode a `Any` from Bytes. To actually perform the conversion from Bytes, you need to use Protobuf.Decode.decode from eriktim/elm-protocol-buffers.

-}
decodeAny : Protobuf.Decode.Decoder Any
decodeAny =
    Proto.Google.Protobuf.Internals_.decodeProto__Google__Protobuf__Any


{-| Declares how to encode a `Any` to Bytes. To actually perform the conversion to Bytes, you need to use Protobuf.Encode.encode from eriktim/elm-protocol-buffers.

-}
encodeAny : Any -> Protobuf.Encode.Encoder
encodeAny =
    Proto.Google.Protobuf.Internals_.encodeProto__Google__Protobuf__Any


{-|  `Any` contains an arbitrary serialized protocol buffer message along with a
 URL that describes the type of the serialized message.

 Protobuf library provides support to pack/unpack Any values in the form
 of utility functions or additional generated methods of the Any type.

 Example 1: Pack and unpack a message in C++.

     Foo foo = ...;
     Any any;
     any.PackFrom(foo);
     ...
     if (any.UnpackTo(&foo)) {
       ...
     }

 Example 2: Pack and unpack a message in Java.

     Foo foo = ...;
     Any any = Any.pack(foo);
     ...
     if (any.is(Foo.class)) {
       foo = any.unpack(Foo.class);
     }

  Example 3: Pack and unpack a message in Python.

     foo = Foo(...)
     any = Any()
     any.Pack(foo)
     ...
     if any.Is(Foo.DESCRIPTOR):
       any.Unpack(foo)
       ...

  Example 4: Pack and unpack a message in Go

      foo := &pb.Foo{...}
      any, err := anypb.New(foo)
      if err != nil {
        ...
      }
      ...
      foo := &pb.Foo{}
      if err := any.UnmarshalTo(foo); err != nil {
        ...
      }

 The pack methods provided by protobuf library will by default use
 'type.googleapis.com/full.type.name' as the type URL and the unpack
 methods only use the fully qualified type name after the last '/'
 in the type URL, for example "foo.bar.com/x/y.z" will yield type
 name "y.z".


 JSON
 ====
 The JSON representation of an `Any` value uses the regular
 representation of the deserialized, embedded message, with an
 additional field `@type` which contains the type URL. Example:

     package google.profile;
     message Person {
       string first_name = 1;
       string last_name = 2;
     }

     {
       "@type": "type.googleapis.com/google.profile.Person",
       "firstName": <string>,
       "lastName": <string>
     }

 If the embedded message type is well-known and has a custom JSON
 representation, that representation will be embedded adding a field
 `value` which holds the custom JSON in addition to the `@type`
 field. Example (for message [google.protobuf.Duration][]):

     {
       "@type": "type.googleapis.com/google.protobuf.Duration",
       "value": "1.212s"
     }



## Fields

### typeUrl

 A URL/resource name that uniquely identifies the type of the serialized
 protocol buffer message. This string must contain at least
 one "/" character. The last segment of the URL's path must represent
 the fully qualified name of the type (as in
 `path/google.protobuf.Duration`). The name should be in a canonical form
 (e.g., leading "." is not accepted).

 In practice, teams usually precompile into the binary all types that they
 expect it to use in the context of Any. However, for URLs which use the
 scheme `http`, `https`, or no scheme, one can optionally set up a type
 server that maps type URLs to message definitions as follows:

 * If no scheme is provided, `https` is assumed.
 * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   value in binary format, or produce an error.
 * Applications are allowed to cache lookup results based on the
   URL, or have them precompiled into a binary to avoid any
   lookup. Therefore, binary compatibility needs to be preserved
   on changes to types. (Use versioned type names to manage
   breaking changes.)

 Note: this functionality is not currently available in the official
 protobuf release, and it is not used for type URLs beginning with
 type.googleapis.com.

 Schemes other than `http`, `https` (or the empty scheme) might be
 used with implementation specific semantics.



### value

 Must be a valid serialized protocol buffer of the above specified type.


-}
type alias Any =
    Proto.Google.Protobuf.Internals_.Proto__Google__Protobuf__Any
